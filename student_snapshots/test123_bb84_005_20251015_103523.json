{
  "student_id": "test123",
  "protocol": "bb84",
  "snapshot_number": 5,
  "timestamp": "2025-10-15T10:35:23.482385",
  "time_since_last_change": 1450.195732,
  "code": [
    "# coding: utf-8",
    "# coding: utf-8",
    "# ",
    "import random",
    "",
    "class StudentQuantumHost:",
    "",
    "    def __init__(self, name):",
    "        self.name = name",
    "        self.random_bits = []",
    "        self.measurement_bases = []",
    "        self.quantum_states = []",
    "        self.received_bases = []",
    "        self.measurement_outcomes = []",
    "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
    "",
    "    \"\"\"",
    "    Create a method that accepts an integer parameter specifying the quantity of qubits to prepare.",
    "    Print a message indicating the host is preparing this quantity of qubits.",
    "    Clear and reinitialize three instance lists: one for random bits, one for bases, and one for quantum states.",
    "    For each qubit in the specified quantity:",
    "    - Generate a random bit (0 or 1)",
    "    - Generate a random basis (0 or 1)",
    "    - If basis is 0: encode bit 0 as \"|0⟩\" and bit 1 as \"|1⟩\"",
    "    - If basis is 1: encode bit 0 as \"|+⟩\" and bit 1 as \"|-⟩\"",
    "    - Append the random bit to the first list, the basis to the second list, and the encoded state to the third list",
    "    After processing all qubits, print a message showing how many qubits were prepared.",
    "    Return the list of encoded quantum states.",
    "    \"\"\"",
    "",
    "    def bb84_send_qubits(self, num_qubits):",
    "        print(f\"{self.name} is preparing {num_qubits} qubits...\")",
    "        self.random_bits = []",
    "        self.measurement_bases = []",
    "        self.quantum_states = []",
    "",
    "        for _ in range(num_qubits):",
    "            bit = random.randint(0, 1)",
    "            basis = random.randint(0, 1)",
    "",
    "            if basis == 0:",
    "                state = \"|0⟩\" if bit == 0 else \"|1⟩\"",
    "            else:",
    "                state = \"|+⟩\" if bit == 0 else \"|-⟩\"",
    "",
    "            self.random_bits.append(bit)",
    "            self.measurement_bases.append(basis)",
    "            self.quantum_states.append(state)",
    "",
    "        print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
    "        return self.quantum_states",
    "",
    "    \"\"\"",
    "    Create a method that accepts two parameters: a quantum state string and a channel reference.",
    "    Generate a random measurement basis (0 or 1) and append it to the received bases list.",
    "    Perform measurement based on the following rules:",
    "    - If measurement basis is 0 (rectilinear):",
    "      * State \"|0⟩\" yields outcome 0",
    "      * State \"|1⟩\" yields outcome 1",
    "      * States \"|+⟩\" or \"|-⟩\" yield random outcome (0 or 1)",
    "    - If measurement basis is 1 (diagonal):",
    "      * State \"|+⟩\" yields outcome 0",
    "      * State \"|-⟩\" yields outcome 1",
    "      * States \"|0⟩\" or \"|1⟩\" yield random outcome (0 or 1)",
    "    - For any other state, yield random outcome (0 or 1)",
    "    Append the measurement outcome to the measurement outcomes list.",
    "    Return True to indicate successful processing.",
    "",
    "\"\"\"",
    "",
    "    def process_received_qbit(self, qbit, from_channel):",
    "        basis = random.randint(0, 1)",
    "        self.received_bases.append(basis)",
    "",
    "        if basis == 0:  # Rectilinear (Z) basis",
    "            if qbit == \"|0⟩\":",
    "                outcome = 0",
    "            elif qbit == \"|1⟩\":",
    "                outcome = 1",
    "            elif qbit == \"|+⟩\" or qbit == \"|-⟩\":",
    "                outcome = random.randint(0, 1)",
    "            else:",
    "                outcome = random.randint(0, 1)",
    "        else:  # Diagonal (X) basis",
    "            if qbit == \"|+⟩\":",
    "                outcome = 0",
    "            elif qbit == \"|-⟩\":",
    "                outcome = 1",
    "            elif qbit == \"|0⟩\" or qbit == \"|1⟩\":",
    "                outcome = random.randint(0, 1)",
    "            else:",
    "                outcome = random.randint(0, 1)",
    "",
    "        self.measurement_outcomes.append(outcome)",
    "        return True",
    "",
    "    \"\"\"",
    "    Create a method that accepts two parameters: both are lists of basis values representing sender and receiver bases.",
    "    Print a message indicating the host is comparing basis choices.",
    "    Create two empty lists: one for matching indices and one for corresponding bit values.",
    "    Iterate through both basis lists simultaneously with enumeration:",
    "    - For each index where both basis values are equal, append the index to the matching indices list",
    "    - If the index is valid for the measurement outcomes list, append the corresponding measurement outcome to the bits list",
    "    - Otherwise, if the index is valid for the random bits list, append the corresponding random bit to the bits list",
    "    Calculate total comparisons as the minimum length of the two basis lists.",
    "    Calculate the match proportion (matching count divided by total, or 0 if total is 0).",
    "    Print a message showing: \"Matches found: X / Y (Z%)\" where X is matches, Y is total, and Z is percentage with 1 decimal place.",
    "    Return both the matching indices list and the corresponding bits list.",
    "    Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
    "    Print a message indicating the host is calculating error rate.",
    "    Initialize two counters to zero: one for total comparisons and one for errors.",
    "    Iterate through the sample positions and reference bits simultaneously:",
    "    - For each position, if it's a valid index in the measurement outcomes list:",
    "      * Increment the comparison counter",
    "      * If the measurement outcome at that position doesn't match the reference bit, increment the error counter",
    "    - Otherwise, if the position is valid in the random bits list:",
    "      * Increment the comparison counter",
    "      * If the random bit at that position doesn't match the reference bit, increment the error counter",
    "    Calculate the error rate as errors divided by comparisons (or 0.0 if comparisons is 0).",
    "    Print a message showing: \"Error rate: X% (Y/Z)\" where X is the rate as percentage with 2 decimals, Y is error count, Z is comparison count.",
    "    Return the calculated error rate.",
    "    \"\"\"",
    "",
    "    #def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
    ""
  ],
  "code_length": 5781,
  "line_count": 125,
  "file_hash": "89d6e8be3f981a8753bc01a8020377c2",
  "changes": {
    "lines_added": 2,
    "lines_removed": 0,
    "code_length_change": -56,
    "time_spent_seconds": 1450.2,
    "time_spent": "24m 10s"
  }
}