{
  "student_id": "tst123",
  "protocol": "bb84",
  "snapshot_number": 1,
  "timestamp": "2025-10-14T12:26:19.647963",
  "time_since_last_change": 0,
  "code": [
    "# coding: utf-8",
    "import random",
    "",
    "class StudentQuantumHost:",
    "",
    "    def __init__(self, name):",
    "        self.name = name",
    "        self.random_bits = []",
    "        self.measurement_bases = []",
    "        self.quantum_states = []",
    "        self.received_bases = []",
    "        self.measurement_outcomes = []",
    "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
    "",
    "    def bb84_send_qubits(self, num_qubits):",
    "        print(f\"{self.name} is preparing {num_qubits} qubits...\")",
    "        self.random_bits = []",
    "        self.measurement_bases = []",
    "        self.quantum_states = []",
    "        self.num_qubits=100",
    "",
    "        for _ in range(num_qubits):",
    "            classical_bit = random.randint(0, 1)",
    "            preparation_basis = random.randint(0, 1)",
    "",
    "            if preparation_basis == 0:",
    "                quantum_state = \"|0⟩\" if classical_bit == 0 else \"|1⟩\"",
    "            else:",
    "                quantum_state = \"|+⟩\" if classical_bit == 0 else \"|-⟩\"",
    "",
    "            self.random_bits.append(classical_bit)",
    "            self.measurement_bases.append(preparation_basis)",
    "            self.quantum_states.append(quantum_state)",
    "",
    "        print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
    "        return self.quantum_states",
    "",
    "    def process_received_qbit(self, qbit, from_channel):",
    "        measurement_basis = random.randint(0, 1)",
    "        self.received_bases.append(measurement_basis)",
    "",
    "        if measurement_basis == 0:",
    "            if qbit == \"|0⟩\":",
    "                outcome = 0",
    "            elif qbit == \"|1⟩\":",
    "                outcome = 1",
    "            elif qbit == \"|+⟩\" or qbit == \"|-⟩\":",
    "                outcome = random.randint(0, 1)",
    "            else:",
    "                outcome = random.randint(0, 1)",
    "        else:",
    "            if qbit == \"|+⟩\":",
    "                outcome = 0",
    "            elif qbit == \"|-⟩\":",
    "                outcome = 1",
    "            elif qbit == \"|0⟩\" or qbit == \"|1⟩\":",
    "                outcome = random.randint(0, 1)",
    "            else:",
    "                outcome = random.randint(0, 1)",
    "",
    "        self.measurement_outcomes.append(outcome)",
    "        return True",
    "",
    "    def bb84_reconcile_bases(self, alice_bases, bob_bases):",
    "        print(f\"{self.name} is comparing basis choices...\")",
    "        matching_indices = []",
    "        corresponding_bits = []",
    "",
    "        for i, (alice_basis, bob_basis) in enumerate(zip(alice_bases, bob_bases)):",
    "            if alice_basis == bob_basis:",
    "                matching_indices.append(i)",
    "                if i < len(self.measurement_outcomes):",
    "                    corresponding_bits.append(self.measurement_outcomes[i])",
    "                elif i < len(self.random_bits):",
    "                    corresponding_bits.append(self.random_bits[i])",
    "",
    "        total_comparisons = min(len(alice_bases), len(bob_bases))",
    "        matches_found = len(matching_indices)",
    "        match_proportion = matches_found / total_comparisons if total_comparisons > 0 else 0",
    "",
    "        print(f\"Matches found: {matches_found} / {total_comparisons} ({match_proportion*100:.1f}%)\")",
    "        return matching_indices, corresponding_bits",
    "",
    "    def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
    "        print(f\"{self.name} is calculating error rate...\")",
    "        comparison_count = 0",
    "        error_count = 0",
    "",
    "        for pos, ref_bit in zip(sample_positions, reference_bits):",
    "            if pos < len(self.measurement_outcomes):",
    "                comparison_count += 1",
    "                if self.measurement_outcomes[pos] != ref_bit:",
    "                    error_count += 1",
    "            elif pos < len(self.random_bits):",
    "                comparison_count += 1",
    "                if self.random_bits[pos] != ref_bit:",
    "                    error_count += 1",
    "",
    "        error_rate = error_count / comparison_count if comparison_count > 0 else 0.0",
    "        print(f\"Error rate: {error_rate*100:.2f}% ({error_count}/{comparison_count})\")",
    "        return error_rate",
    "",
    "def main():",
    "    print(\"=\" * 70)",
    "    print(\"BB84 QUANTUM KEY DISTRIBUTION PROTOCOL DEMONSTRATION\")",
    "    print(\"=\" * 70)",
    "    print()",
    "",
    "    print(\"STEP 1: Initializing Quantum Hosts\")",
    "    alice = StudentQuantumHost(\"Alice\")",
    "    bob = StudentQuantumHost(\"Bob\")",
    "    print()",
    "",
    "    print(\"STEP 2: Quantum Transmission Phase\")",
    "    num_qubits = 100  # Students: Change this number to use more/fewer qubits!",
    "    quantum_states = alice.bb84_send_qubits(num_qubits)",
    "    print()",
    "",
    "    print(\"STEP 3: Quantum Measurement Phase\")",
    "    for qbit in quantum_states:",
    "        bob.process_received_qbit(qbit, None)",
    "    print(\"Measurement phase complete\")",
    "    print()",
    "",
    "    print(\"STEP 4: Basis Reconciliation Phase\")",
    "    matching_indices, _ = alice.bb84_reconcile_bases(alice.measurement_bases, bob.received_bases)",
    "    matching_indices, _ = bob.bb84_reconcile_bases(alice.measurement_bases, bob.received_bases)",
    "    print()",
    "",
    "    print(\"STEP 5: Error Rate Estimation Phase\")",
    "    if len(matching_indices) > 5:",
    "        sample_positions = matching_indices[:5]",
    "        alice.bb84_estimate_error_rate(sample_positions, [bob.measurement_outcomes[i] for i in sample_positions])",
    "        bob.bb84_estimate_error_rate(sample_positions, [alice.random_bits[i] for i in sample_positions])",
    "",
    "    else:",
    "        print(\"Not enough matching bases for error rate estimation\")",
    "    print()",
    "",
    "if __name__ == \"__main__\":",
    "    main()"
  ],
  "code_length": 5207,
  "line_count": 141,
  "file_hash": "b52eaa2ad17e9723dd0e227fc41bdbe8",
  "changes": {
    "lines_added": 141,
    "lines_removed": 0,
    "code_length_change": 5207,
    "time_spent_seconds": 0,
    "time_spent": "0s"
  }
}