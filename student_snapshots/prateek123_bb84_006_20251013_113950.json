{
  "student_id": "prateek123",
  "protocol": "bb84",
  "snapshot_number": 6,
  "timestamp": "2025-10-13T11:39:50.771093",
  "time_since_last_change": 852.634955,
  "code": [
    "# coding: utf-8",
    "import random",
    "",
    "class StudentQuantumHost:",
    "",
    "    #ef __init__(self, name):",
    "    def __init__(self, name):",
    "        \"\"\"Initialize StudentQuantumHost.",
    "",
    "        Args:",
    "            name (str): Host name (e.g., 'Alice' or 'Bob')",
    "        \"\"\"",
    "        # Store host name for logging",
    "        self.name = name",
    "",
    "        # Preparation (Alice) state",
    "        self.random_bits = []          # classical bits generated for preparation",
    "        self.preparation_bases = []    # preparation bases used for each qubit (0=Z, 1=X)",
    "        self.quantum_states = []       # encoded quantum state representations",
    "",
    "        # Reception (Bob) state",
    "        self.received_bases = []       # bases chosen when receiving/measuring qubits",
    "        self.measurement_outcomes = [] # measurement outcomes (0 or 1)",
    "",
    "        # Common / utility fields (kept empty for compatibility)",
    "        self.sent_bits = []",
    "        self.prepared_qubits = []",
    "        self.sifted_key = []",
    "",
    "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
    "",
    "   #def bb84_send_qubits(self, num_qubits):",
    "def bb84_send_qubits(self, num_qubits):",
    "    print(f\"{self.name} is preparing {num_qubits} qubits...\")",
    "    self.random_bits = []",
    "    self.measurement_bases = []",
    "    self.quantum_states = []",
    "",
    "    for _ in range(num_qubits):",
    "        classical_bit = random.randint(0, 1)",
    "        preparation_basis = random.randint(0, 1)",
    "",
    "        if preparation_basis == 0:",
    "            quantum_state = \"|0⟩\" if classical_bit == 0 else \"|1⟩\"",
    "        else:",
    "            quantum_state = \"|+⟩\" if classical_bit == 0 else \"|-⟩\"",
    "",
    "        self.random_bits.append(classical_bit)",
    "        self.measurement_bases.append(preparation_basis)",
    "        self.quantum_states.append(quantum_state)",
    "",
    "    print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
    "    return self.quantum_states",
    "",
    "    #ef process_received_qbit(self, qbit, from_channel):",
    "",
    "    def process_received_qbit(self, qbit, from_channel=None):",
    "        \"\"\"",
    "        Process an incoming qubit: choose a random measurement basis, record it,",
    "        measure the quantum state using the chosen basis, and store the outcome.",
    "",
    "        Args:",
    "            qbit (str): quantum state string (e.g. '|0⟩', '|+⟩', ...)",
    "            from_channel: optional source channel (unused)",
    "",
    "        Returns:",
    "            bool: True on successful processing",
    "        \"\"\"",
    "        # choose random measurement basis (0 = Z, 1 = X)",
    "        basis = random.randint(0, 1)",
    "",
    "        # record chosen basis",
    "        self.received_bases.append(basis)",
    "",
    "        # perform measurement using the notebook helper",
    "        outcome = measure_quantum_state(qbit, basis)",
    "",
    "        # store measurement outcome",
    "        self.measurement_outcomes.append(outcome)",
    "",
    "        # keep compatibility with other fields if needed",
    "        # (optional) record measured bit into sent_bits/prepared_qubits if protocol expects it",
    "        # self.sent_bits.append(None)",
    "        # self.prepared_qubits.append(qbit)",
    "",
    "        print(f\"{self.name} measured a received qubit in {'Z' if basis==0 else 'X'}-basis -> outcome {outcome}\")",
    "",
    "        return True",
    "",
    "   #def bb84_reconcile_bases(self, alice_bases, bob_bases):",
    "    def bb84_reconcile_bases(self, alice_bases, bob_bases):",
    "        \"\"\"",
    "        Compare Alice and Bob basis choices, return indices where bases match and the corresponding measured bits.",
    "",
    "        Args:",
    "            alice_bases (list): Alice's preparation bases (0=Z, 1=X)",
    "            bob_bases (list): Bob's measurement bases (0=Z, 1=X)",
    "",
    "        Returns:",
    "            tuple: (matching_indices, matching_bits)",
    "        \"\"\"",
    "        print(f\"\\n{self.name} is reconciling bases between participants...\")",
    "",
    "        matching_indices = []",
    "        matching_bits = []",
    "",
    "        # Only iterate up to the shorter list to avoid index errors",
    "        comparisons = min(len(alice_bases), len(bob_bases))",
    "",
    "        for idx in range(comparisons):",
    "            if alice_bases[idx] == bob_bases[idx]:",
    "                matching_indices.append(idx)",
    "                # Record measured value if available",
    "                if idx < len(self.measurement_outcomes):",
    "                    matching_bits.append(self.measurement_outcomes[idx])",
    "",
    "        total_compared = comparisons",
    "        matches = len(matching_indices)",
    "        proportion = (matches / total_compared) if total_compared > 0 else 0.0",
    "",
    "        print(f\"Matches found: {matches} out of {total_compared} comparisons ({proportion:.2%})\")",
    "        print(f\"Matching indices (first 20): {matching_indices[:20]}\")",
    "        print(f\"Matching bits (first 20): {matching_bits[:20]}\")",
    "",
    "        return matching_indices, matching_bits",
    "",
    "    #ef bb84_estimate_error_rate(self, sample_positions, reference_bits):",
    "    def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
    "        \"\"\"",
    "        Estimate the BB84 error rate by comparing sample positions against reference bits.",
    "",
    "        Args:",
    "            sample_positions (list): indices to check",
    "            reference_bits (list): bits to compare against",
    "",
    "        Returns:",
    "            float: error rate (0.0 - 1.0)",
    "        \"\"\"",
    "        print(f\"\\n{self.name} is calculating BB84 error rate from supplied sample...\")",
    "",
    "        comparison_count = 0",
    "        error_count = 0",
    "",
    "        for pos, ref_bit in zip(sample_positions, reference_bits):",
    "            # only compare when we have a recorded measurement for that position",
    "            if 0 <= pos < len(self.measurement_outcomes):",
    "                comparison_count += 1",
    "                if self.measurement_outcomes[pos] != ref_bit:",
    "                    error_count += 1",
    "            else:",
    "                # skip invalid positions quietly (log for debugging)",
    "                print(f\" Skipping invalid sample position: {pos} (no recorded outcome)\")",
    "",
    "        # compute error rate (default to 0.0 if no comparisons)",
    "        error_rate = (error_count / comparison_count) if comparison_count > 0 else 0.0",
    "",
    "        print(f\"Error estimation complete: {error_count} errors / {comparison_count} comparisons -> {error_rate:.2%}\")",
    "",
    "        return error_rate",
    ""
  ],
  "code_length": 5989,
  "line_count": 160,
  "file_hash": "fa8606548026ef31fb2733ab90530878",
  "changes": {
    "lines_added": -30,
    "lines_removed": 30,
    "code_length_change": -1023,
    "time_spent_seconds": 852.6,
    "time_spent": "14m 12s"
  }
}