{
  "student_id": "prateek1234",
  "protocol": "bb84",
  "snapshot_number": 1,
  "timestamp": "2025-10-13T11:15:07.618952",
  "time_since_last_change": 0,
  "code": [
    "# coding: utf-8",
    "# STUDENT ACTIVITY TRACKING SETUP WITH FIREBASE + AUTOMATIC SNAPSHOTS",
    "import importlib",
    "import notebook_tracker",
    "importlib.reload(notebook_tracker)",
    "",
    "# Get student ID (only asked once per session)",
    "try:",
    "    student_id",
    "    print(f\"Welcome back, {student_id}!\")",
    "    print(\"Tracking session active\")",
    "except NameError:",
    "    student_id = input(\"Enter your Student ID: \")",
    "",
    "# Initialize tracker with Firebase cloud storage",
    "# Saves to Firebase (cloud) AND local JSON backups",
    "notebook_tracker.init_tracker(student_id, use_firebase=True)",
    "",
    "# Start automatic snapshot watcher in background",
    "import threading",
    "import time",
    "from pathlib import Path",
    "",
    "def auto_snapshot_watcher():",
    "    \"\"\"Background thread that monitors code changes and creates snapshots\"\"\"",
    "    import watch_student_changes",
    "    import importlib",
    "    importlib.reload(watch_student_changes)",
    "",
    "    try:",
    "        # Create watcher instance",
    "        watcher = watch_student_changes.StudentCodeWatcher(",
    "            student_id=student_id,",
    "            snapshot_interval=3,",
    "            session_id=notebook_tracker.get_session_id(),",
    "            use_firebase=True",
    "        )",
    "",
    "        # Set up file monitoring",
    "        from watchdog.observers import Observer",
    "        observer = Observer()",
    "        observer.schedule(watcher, path='.', recursive=False)",
    "        observer.start()",
    "",
    "        # Keep running until notebook stops",
    "        while True:",
    "            time.sleep(1)",
    "",
    "    except Exception as e:",
    "        print(f\"Snapshot watcher error: {e}\")",
    "",
    "# Start snapshot watcher in background thread",
    "try:",
    "    if 'snapshot_thread' not in globals() or not snapshot_thread.is_alive():",
    "        snapshot_thread = threading.Thread(target=auto_snapshot_watcher, daemon=True)",
    "        snapshot_thread.start()",
    "        print(\"Auto-snapshot: Enabled (monitors BB84 & B92 code changes)\")",
    "except:",
    "    snapshot_thread = threading.Thread(target=auto_snapshot_watcher, daemon=True)",
    "    snapshot_thread.start()",
    "    print(\"Auto-snapshot: Enabled (monitors BB84 & B92 code changes)\")",
    "",
    "print(\"\\nCloud Storage: Firebase (qsimnotebookfinal-e73e9)\")",
    "print(\"Instructor access: python view_firebase.py list\")",
    "print(\"\\nHow it works:\")",
    "print(\"1. Write code in BB84/B92 cells\")",
    "print(\"2. Save with %save command (Cells 11 & 23)\")",
    "print(\"3. Snapshots created automatically every 3 seconds\")",
    "print(\"4. Track final version with Cells 12 & 24\")",
    "print(\"\\nAll snapshots + code saved to Firebase automatically!\")",
    "import random",
    "",
    "class StudentQuantumHost:",
    "",
    "    #ef __init__(self, name):",
    "    def __init__(self, name):",
    "        \"\"\"Initialize StudentQuantumHost.",
    "",
    "        Args:",
    "            name (str): Host name (e.g., 'Alice' or 'Bob')",
    "        \"\"\"",
    "        # Store host name for logging",
    "        self.name = name",
    "",
    "        # Preparation (Alice) state",
    "        self.random_bits = []          # classical bits generated for preparation",
    "        self.preparation_bases = []    # preparation bases used for each qubit (0=Z, 1=X)",
    "        self.quantum_states = []       # encoded quantum state representations",
    "",
    "        # Reception (Bob) state",
    "        self.received_bases = []       # bases chosen when receiving/measuring qubits",
    "        self.measurement_outcomes = [] # measurement outcomes (0 or 1)",
    "",
    "        # Common / utility fields (kept empty for compatibility)",
    "        self.sent_bits = []",
    "        self.prepared_qubits = []",
    "        self.sifted_key = []",
    "",
    "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
    "",
    "   #def bb84_send_qubits(self, num_qubits):",
    "",
    "    #ef process_received_qbit(self, qbit, from_channel):",
    "",
    "   #def bb84_reconcile_bases(self, alice_bases, bob_bases):",
    "",
    "    #ef bb84_estimate_error_rate(self, sample_positions, reference_bits):",
    ""
  ],
  "code_length": 3651,
  "line_count": 108,
  "file_hash": "0e60e1b9168a367fe3d072dc5fc04de0",
  "changes": {
    "lines_added": 108,
    "lines_removed": 0,
    "code_length_change": 3651,
    "time_spent_seconds": 0,
    "time_spent": "0s"
  }
}