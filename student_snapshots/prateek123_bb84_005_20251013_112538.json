{
  "student_id": "prateek123",
  "protocol": "bb84",
  "snapshot_number": 5,
  "timestamp": "2025-10-13T11:25:38.136138",
  "time_since_last_change": 142.174778,
  "code": [
    "# coding: utf-8",
    "import random",
    "",
    "class StudentQuantumHost:",
    "",
    "    #ef __init__(self, name):",
    "    def __init__(self, name):",
    "        \"\"\"Initialize StudentQuantumHost.",
    "",
    "        Args:",
    "            name (str): Host name (e.g., 'Alice' or 'Bob')",
    "        \"\"\"",
    "        # Store host name for logging",
    "        self.name = name",
    "",
    "        # Preparation (Alice) state",
    "        self.random_bits = []          # classical bits generated for preparation",
    "        self.preparation_bases = []    # preparation bases used for each qubit (0=Z, 1=X)",
    "        self.quantum_states = []       # encoded quantum state representations",
    "",
    "        # Reception (Bob) state",
    "        self.received_bases = []       # bases chosen when receiving/measuring qubits",
    "        self.measurement_outcomes = [] # measurement outcomes (0 or 1)",
    "",
    "        # Common / utility fields (kept empty for compatibility)",
    "        self.sent_bits = []",
    "        self.prepared_qubits = []",
    "        self.sifted_key = []",
    "",
    "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
    "",
    "   #def bb84_send_qubits(self, num_qubits):",
    "    def bb84_send_qubits(self, num_qubits):",
    "        \"\"\"",
    "        Prepare and return a list of BB84 quantum state strings.",
    "",
    "        Args:",
    "            num_qubits (int): Number of qubits to prepare",
    "",
    "        Returns:",
    "            list: Prepared quantum state representations (e.g. '|0⟩','|+⟩', ...)",
    "        \"\"\"",
    "        print(f\"\\n{self.name} is preparing to send {num_qubits} qubits (BB84)...\")",
    "",
    "        # Reset preparation-related storage",
    "        self.random_bits = []",
    "        self.preparation_bases = []",
    "        self.quantum_states = []",
    "",
    "        # Keep compatibility fields in sync",
    "        self.sent_bits = []",
    "        self.prepared_qubits = []",
    "",
    "        if num_qubits <= 0:",
    "            print(\"No qubits requested; returning empty list.\")",
    "            return []",
    "",
    "        for i in range(num_qubits):",
    "            # classical random bit and random basis (0 = Z, 1 = X)",
    "            bit = random.randint(0, 1)",
    "            basis = random.randint(0, 1)",
    "",
    "            # encode into a quantum-state string using existing helper",
    "            qstate = prepare_quantum_state(bit, basis)",
    "",
    "            # store internal state",
    "            self.random_bits.append(bit)",
    "            self.preparation_bases.append(basis)",
    "            self.quantum_states.append(qstate)",
    "",
    "            # compatibility aliases",
    "            self.sent_bits.append(bit)",
    "            self.prepared_qubits.append(qstate)",
    "",
    "        # Summary",
    "        preview_bits = self.random_bits[:10]",
    "        preview_bases = self.preparation_bases[:10]",
    "        print(f\"Prepared {len(self.quantum_states)} qubits.\")",
    "        print(f\"Random bits (first 10): {preview_bits}\")",
    "        print(f\"Preparation bases (first 10) [0=Z,1=X]: {preview_bases}\")",
    "        print(f\"Quantum states (first 10): {self.quantum_states[:10]}\")",
    "",
    "        return self.quantum_states",
    "",
    "    #ef process_received_qbit(self, qbit, from_channel):",
    "",
    "    def process_received_qbit(self, qbit, from_channel=None):",
    "        \"\"\"",
    "        Process an incoming qubit: choose a random measurement basis, record it,",
    "        measure the quantum state using the chosen basis, and store the outcome.",
    "",
    "        Args:",
    "            qbit (str): quantum state string (e.g. '|0⟩', '|+⟩', ...)",
    "            from_channel: optional source channel (unused)",
    "",
    "        Returns:",
    "            bool: True on successful processing",
    "        \"\"\"",
    "        # choose random measurement basis (0 = Z, 1 = X)",
    "        basis = random.randint(0, 1)",
    "",
    "        # record chosen basis",
    "        self.received_bases.append(basis)",
    "",
    "        # perform measurement using the notebook helper",
    "        outcome = measure_quantum_state(qbit, basis)",
    "",
    "        # store measurement outcome",
    "        self.measurement_outcomes.append(outcome)",
    "",
    "        # keep compatibility with other fields if needed",
    "        # (optional) record measured bit into sent_bits/prepared_qubits if protocol expects it",
    "        # self.sent_bits.append(None)",
    "        # self.prepared_qubits.append(qbit)",
    "",
    "        print(f\"{self.name} measured a received qubit in {'Z' if basis==0 else 'X'}-basis -> outcome {outcome}\")",
    "",
    "        return True",
    "",
    "   #def bb84_reconcile_bases(self, alice_bases, bob_bases):",
    "    def bb84_reconcile_bases(self, alice_bases, bob_bases):",
    "        \"\"\"",
    "        Compare Alice and Bob basis choices, return indices where bases match and the corresponding measured bits.",
    "",
    "        Args:",
    "            alice_bases (list): Alice's preparation bases (0=Z, 1=X)",
    "            bob_bases (list): Bob's measurement bases (0=Z, 1=X)",
    "",
    "        Returns:",
    "            tuple: (matching_indices, matching_bits)",
    "        \"\"\"",
    "        print(f\"\\n{self.name} is reconciling bases between participants...\")",
    "",
    "        matching_indices = []",
    "        matching_bits = []",
    "",
    "        # Only iterate up to the shorter list to avoid index errors",
    "        comparisons = min(len(alice_bases), len(bob_bases))",
    "",
    "        for idx in range(comparisons):",
    "            if alice_bases[idx] == bob_bases[idx]:",
    "                matching_indices.append(idx)",
    "                # Record measured value if available",
    "                if idx < len(self.measurement_outcomes):",
    "                    matching_bits.append(self.measurement_outcomes[idx])",
    "",
    "        total_compared = comparisons",
    "        matches = len(matching_indices)",
    "        proportion = (matches / total_compared) if total_compared > 0 else 0.0",
    "",
    "        print(f\"Matches found: {matches} out of {total_compared} comparisons ({proportion:.2%})\")",
    "        print(f\"Matching indices (first 20): {matching_indices[:20]}\")",
    "        print(f\"Matching bits (first 20): {matching_bits[:20]}\")",
    "",
    "        return matching_indices, matching_bits",
    "",
    "    #ef bb84_estimate_error_rate(self, sample_positions, reference_bits):",
    "    def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
    "        \"\"\"",
    "        Estimate the BB84 error rate by comparing sample positions against reference bits.",
    "",
    "        Args:",
    "            sample_positions (list): indices to check",
    "            reference_bits (list): bits to compare against",
    "",
    "        Returns:",
    "            float: error rate (0.0 - 1.0)",
    "        \"\"\"",
    "        print(f\"\\n{self.name} is calculating BB84 error rate from supplied sample...\")",
    "",
    "        comparison_count = 0",
    "        error_count = 0",
    "",
    "        for pos, ref_bit in zip(sample_positions, reference_bits):",
    "            # only compare when we have a recorded measurement for that position",
    "            if 0 <= pos < len(self.measurement_outcomes):",
    "                comparison_count += 1",
    "                if self.measurement_outcomes[pos] != ref_bit:",
    "                    error_count += 1",
    "            else:",
    "                # skip invalid positions quietly (log for debugging)",
    "                print(f\" Skipping invalid sample position: {pos} (no recorded outcome)\")",
    "",
    "        # compute error rate (default to 0.0 if no comparisons)",
    "        error_rate = (error_count / comparison_count) if comparison_count > 0 else 0.0",
    "",
    "        print(f\"Error estimation complete: {error_count} errors / {comparison_count} comparisons -> {error_rate:.2%}\")",
    "",
    "        return error_rate",
    ""
  ],
  "code_length": 7012,
  "line_count": 190,
  "file_hash": "6bb527868428ebdfd33c5403fca1319a",
  "changes": {
    "lines_added": 32,
    "lines_removed": 0,
    "code_length_change": 1337,
    "time_spent_seconds": 142.2,
    "time_spent": "2m 22s"
  }
}