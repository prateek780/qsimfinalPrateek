{
  "student_id": "test123",
  "protocol": "b92",
  "snapshot_number": 5,
  "timestamp": "2025-10-15T10:42:33.938900",
  "time_since_last_change": 60.444194,
  "code": [
    "# coding: utf-8",
    "# coding: utf-8",
    "import random",
    "",
    "class StudentB92Host:",
    "    # Student's B92 QKD implementation class with instance methods.",
    "    # All prompts are included above their respective implementations.",
    "    #",
    "    # B92 Protocol Summary:",
    "    # - Alice encodes: bit 0 -> |0⟩, bit 1 -> |+⟩ = (|0⟩ + |1⟩)/√2",
    "    # - Bob measures randomly in Z or X basis",
    "    # - Bob keeps only results where he measures |1⟩ (outcome = 1)",
    "    # - If Bob measures |1⟩ in Z basis -> Alice sent |+⟩ (bit 1)",
    "    # - If Bob measures |1⟩ in X basis -> Alice sent |0⟩ (bit 0)",
    "",
    "    def __init__(self, name):",
    "        \"\"\"",
    "        Initialize a StudentB92Host instance for the B92 protocol.",
    "",
    "        Args:",
    "            name (str): The name of the host (e.g., 'Alice' or 'Bob')",
    "        \"\"\"",
    "        # Store the host name for logging purposes",
    "        self.name = name",
    "",
    "        # Initialize empty lists for B92 protocol state tracking",
    "        self.sent_bits = []  # Bits that were sent",
    "        self.prepared_qubits = []  # Prepared quantum states",
    "        self.received_measurements = []  # Measurements received",
    "        self.sifted_key = []  # Final sifted key after reconciliation",
    "        self.random_bits = []  # Random bits generated",
    "        self.measurement_outcomes = []  # Measurement results obtained",
    "        self.received_bases = []  # Bases used for receiving qubits",
    "",
    "        # Print initialization message",
    "        print(f\"StudentB92Host '{self.name}' initialized successfully!\")",
    "",
    "    \"\"\"",
    "    Create a method that accepts a single binary value (0 or 1) as input.",
    "    Validate that the input is either 0 or 1; if not, raise a ValueError with an appropriate message.",
    "    Map the binary value to a quantum state using the following encoding:",
    "    - If the value is 0, return the state string \"|0⟩\"",
    "    - If the value is 1, return the state string \"|+⟩\"",
    "    Return the prepared quantum state string.",
    "",
    "    def b92_prepare_qubit(self, bit):",
    "",
    "        Prepare a qubit based on a classical bit following the B92 protocol.",
    "",
    "        Args:",
    "            bit (int): Classical bit value (0 or 1)",
    "",
    "        Returns:",
    "            str: Prepared quantum state ('|0⟩' or '|+⟩')",
    "",
    "        Raises:",
    "            ValueError: If bit is not 0 or 1",
    "",
    "        # Validate input bit",
    "        if bit not in [0, 1]:",
    "            raise ValueError(f\"Invalid bit value: {bit}. Must be 0 or 1.\")",
    "",
    "        # Map bit to non-orthogonal quantum state (B92 encoding)",
    "        if bit == 0:",
    "            qubit = '|0⟩'  # Bit 0 maps to |0⟩ state",
    "        else:  # bit == 1",
    "            qubit = '|+⟩'  # Bit 1 maps to |+⟩ superposition state",
    "",
    "        # Return the prepared qubit",
    "        return qubit",
    "",
    "    Create a method that accepts a quantum state string as input.",
    "    Randomly select a measurement basis from two options: \"Z\" or \"X\".",
    "    Perform measurement following these rules:",
    "    - If the selected basis is \"Z\":",
    "      * If the state is '|0⟩', set outcome to 0 (deterministic)",
    "      * If the state is '|+⟩', set outcome to a random value (0 or 1 with equal probability)",
    "      * For any other state, set outcome to a random value (0 or 1)",
    "    - If the selected basis is \"X\":",
    "      * If the state is '|+⟩', set outcome to 0 (deterministic)",
    "      * If the state is '|0⟩', set outcome to a random value (0 or 1 with equal probability)",
    "      * For any other state, set outcome to a random value (0 or 1)",
    "    Return a tuple containing the measurement outcome and the selected basis.",
    "",
    "    def b92_measure_qubit(self, qubit):",
    "",
    "        Measure a qubit in a randomly chosen basis following B92 protocol.",
    "",
    "        Args:",
    "            qubit (str): Quantum state to measure ('|0⟩' or '|+⟩')",
    "",
    "        Returns:",
    "            tuple: (outcome, basis) - measurement outcome (0 or 1) and basis used (\"Z\" or \"X\")",
    "",
    "        # Randomly choose measurement basis",
    "        basis = random.choice([\"Z\", \"X\"])",
    "",
    "        # Perform measurement based on chosen basis",
    "        if basis == \"Z\":  # Measuring in Z (computational) basis",
    "            if qubit == '|0⟩':",
    "                outcome = 0  # |0⟩ in Z basis: deterministic outcome 0",
    "            elif qubit == '|+⟩':",
    "                outcome = random.randint(0, 1)  # |+⟩ in Z basis: 50% probability for 0 or 1",
    "            else:",
    "                # Handle other states if present",
    "                outcome = random.randint(0, 1)",
    "",
    "        else:  # basis == \"X\" - Measuring in X (Hadamard) basis",
    "            if qubit == '|+⟩':",
    "                outcome = 0  # |+⟩ in X basis: deterministic outcome 0 (+1 eigenstate)",
    "            elif qubit == '|0⟩':",
    "                outcome = random.randint(0, 1)  # |0⟩ in X basis: 50% probability for 0 or 1",
    "            else:",
    "                # Handle other states if present",
    "                outcome = random.randint(0, 1)",
    "",
    "        # Return both outcome and basis",
    "        return outcome, basis",
    "    Create a method that accepts two parameters: a list of transmitted bits and a list of measurement tuples (each containing an outcome and a basis).",
    "    Print a message indicating the host is performing sifting.",
    "    Initialize two empty lists: one for storing indices of conclusive results and one for storing the sifted key bits.",
    "    Iterate through the measurement tuples with enumeration to track positions:",
    "    - For each tuple where the outcome equals 1 (conclusive result):",
    "      * Append the current index to the indices list",
    "      * If the basis is \"Z\", append bit value 1 to the sifted key list",
    "      * If the basis is \"X\", append bit value 0 to the sifted key list",
    "    Store the sifted key list in the instance variable for future use.",
    "    Calculate the total number of measurements and the count of conclusive results.",
    "    Calculate the sifting efficiency as the ratio of conclusive results to total measurements (or 0 if total is 0).",
    "    Print a summary showing: total measurements, conclusive results count, sifting efficiency as a percentage with 2 decimals, and the first 10 bits of the sifted key.",
    "    Return a tuple containing the indices list and the sifted key list.",
    "",
    "    def b92_sifting(self, sent_bits, received_measurements):",
    "",
    "        Perform sifting stage of B92 protocol by keeping only conclusive measurements.",
    "",
    "        Args:",
    "            sent_bits (list): Bits that were sent by Alice",
    "            received_measurements (list): List of (outcome, basis) tuples from Bob's measurements",
    "",
    "        Returns:",
    "            tuple: (sifted_indices, sifted_key) - indices of conclusive results and corresponding bits",
    "",
    "        print(f\"\\n{self.name} is performing B92 sifting...\")",
    "",
    "        # Initialize collections for sifted data",
    "        sifted_indices = []",
    "        sifted_key = []",
    "",
    "        # Iterate through received measurements with their positions",
    "        for index, (outcome, basis) in enumerate(received_measurements):",
    "            # Keep only conclusive outcomes (result = 1)",
    "            if outcome == 1:",
    "                # Record the index of this conclusive measurement",
    "                sifted_indices.append(index)",
    "",
    "                # Determine the bit based on basis used",
    "                if basis == \"Z\":",
    "                    # In Z basis: outcome 1 conclusively indicates sender sent |+⟩ (bit 1)",
    "                    bit = 1",
    "                else:  # basis == \"X\"",
    "                    # In X basis: outcome 1 conclusively indicates sender sent |0⟩ (bit 0)",
    "                    bit = 0",
    "",
    "                # Add the determined bit to sifted key",
    "                sifted_key.append(bit)",
    "",
    "        # Store sifted key for future use",
    "        self.sifted_key = sifted_key",
    "",
    "        # Display sifting summary",
    "        total_measurements = len(received_measurements)",
    "        conclusive_count = len(sifted_key)",
    "        sifting_efficiency = conclusive_count / total_measurements if total_measurements > 0 else 0",
    "",
    "        print(f\"Total measurements: {total_measurements}\")",
    "        print(f\"Conclusive results: {conclusive_count}\")",
    "        print(f\"Sifting efficiency: {sifting_efficiency:.2%}\")",
    "        print(f\"Sifted key (first 10): {sifted_key[:10]}\")",
    "",
    "        # Return sifted indices and key",
    "        return sifted_indices, sifted_key",
    "",
    "    Create a method that accepts an integer parameter specifying how many qubits to generate.",
    "    Print a message indicating the host is preparing to send the specified number of qubits.",
    "    Clear and reinitialize two instance lists: one for transmitted bits and one for prepared qubits.",
    "    For each qubit in the specified quantity:",
    "    - Generate a random binary value (0 or 1)",
    "    - Append this value to the transmitted bits list",
    "    - Call the preparation method with this binary value to get a quantum state",
    "    - Append the returned quantum state to the prepared qubits list",
    "    After processing all qubits, print a success message showing how many qubits were prepared.",
    "    Print the first 10 elements of the transmitted bits list with a label.",
    "    Print the first 10 elements of the prepared qubits list with a label.",
    "    Return the list of prepared quantum states.",
    "    \"\"\"",
    "    def b92_send_qubits(self, num_qubits):",
    "        \"\"\"",
    "        Generate random bits and prepare qubits for transmission using B92 protocol.",
    "",
    "        Args:",
    "            num_qubits (int): Number of qubits to prepare and send",
    "",
    "        Returns:",
    "            list: List of prepared quantum states",
    "        \"\"\"",
    "        print(f\"\\n{self.name} is preparing to send {num_qubits} qubits using B92 protocol...\")",
    "",
    "        # Initialize/reset internal storage",
    "        self.sent_bits = []",
    "        self.prepared_qubits = []",
    "",
    "        # Generate random bits and prepare corresponding qubits",
    "        for i in range(num_qubits):",
    "            # Generate random bit (0 or 1)",
    "            random_bit = random.randint(0, 1)",
    "",
    "            # Store the bit internally",
    "            self.sent_bits.append(random_bit)",
    "",
    "            # Prepare qubit using b92_prepare_qubit method",
    "            qubit = self.b92_prepare_qubit(random_bit)",
    "",
    "            # Store the prepared qubit",
    "            self.prepared_qubits.append(qubit)",
    "",
    "        # Display summary",
    "        print(f\"\\n{self.name} prepared {num_qubits} qubits successfully!\")",
    "        print(f\"Random bits (first 10): {self.sent_bits[:10]}\")",
    "        print(f\"Prepared qubits (first 10): {self.prepared_qubits[:10]}\")",
    "",
    "        # Return the prepared qubits",
    "        return self.prepared_qubits",
    "",
    "    \"\"\"",
    "    Create a method that accepts two parameters: a quantum state string and an optional channel reference.",
    "    Call the measurement method with the quantum state to obtain an outcome and basis.",
    "    Append a tuple containing the outcome and basis to the received measurements list.",
    "    Return True to confirm successful processing.",
    "    \"\"\"",
    "    def b92_process_received_qbit(self, qbit, from_channel=None):",
    "        \"\"\"",
    "        Process a received qubit by measuring it using B92 protocol.",
    "",
    "        Args:",
    "            qbit (str): The quantum state received ('|0⟩' or '|+⟩')",
    "            from_channel: The channel from which the qubit was received (optional)",
    "",
    "        Returns:",
    "            bool: True to confirm successful processing",
    "            \"\"\"",
    "",
    "        # Measure the qubit using b92_measure_qubit method",
    "        outcome, basis = self.b92_measure_qubit(qbit)",
    "",
    "        # Store both the measurement outcome and the chosen basis",
    "        self.received_measurements.append((outcome, basis))",
    "",
    "        # Return True to confirm processing",
    "        return True",
    "",
    "    \"\"\"",
    "    Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
    "    Print a message indicating the host is calculating the error rate.",
    "    Initialize two counters to zero: one for total comparisons and one for errors detected.",
    "    Iterate through the sample positions and reference bits simultaneously:",
    "    - For each position, check if it's a valid index within the sifted key list",
    "    - If valid:",
    "      * Increment the comparison counter",
    "      * If the sifted key value at that position does not match the reference bit, increment the error counter",
    "    After iteration, calculate the error rate:",
    "    - If comparison count is greater than 0, divide error count by comparison count",
    "    - Otherwise, set error rate to 0.0",
    "    Print a completion message.",
    "    Print the number of errors found.",
    "    Print the total number of comparisons made.",
    "    Print the calculated error rate as a percentage with 2 decimal places.",
    "    Return the error rate as a floating-point value.",
    "",
    "    def b92_estimate_error_rate(self, sample_positions, reference_bits):",
    "",
    "        Estimate the error rate by comparing sample positions from sifted key with reference bits.",
    "",
    "        Args:",
    "            sample_positions (list): Indices of sifted key bits to check",
    "            reference_bits (list): Reference bit values to compare against",
    "",
    "        Returns:",
    "            float: Calculated error rate (0.0 to 1.0)",
    "",
    "        print(f\"\\n{self.name} is calculating B92 error rate...\")",
    "",
    "        # Initialize counters",
    "        comparison_count = 0",
    "        error_count = 0",
    "",
    "        # Iterate through sample positions and reference bits",
    "        for position, reference_bit in zip(sample_positions, reference_bits):",
    "            # Check if position is valid relative to sifted key",
    "            if position < len(self.sifted_key):",
    "                # Increase comparison count",
    "                comparison_count += 1",
    "",
    "                # Check for mismatch between sifted key and reference bit",
    "                if self.sifted_key[position] != reference_bit:",
    "                    # Increase error count",
    "                    error_count += 1",
    "",
    "        # Calculate error rate (default to 0.0 if no comparisons)",
    "        if comparison_count > 0:",
    "            error_rate = error_count / comparison_count",
    "        else:",
    "            error_rate = 0.0",
    "",
    "        # Display summary",
    "        print(f\"\\n{self.name} B92 error rate estimation complete!\")",
    "        print(f\"Errors found: {error_count}\")",
    "        print(f\"Total comparisons: {comparison_count}\")",
    "        print(f\"Calculated error rate: {error_rate:.2%}\")",
    "",
    "        # Return the computed error rate",
    "        return error_rate",
    "        \"\"\"",
    ""
  ],
  "code_length": 13899,
  "line_count": 324,
  "file_hash": "36f3c55f87f0f5df42c1a005adca9396",
  "changes": {
    "lines_added": 3,
    "lines_removed": 0,
    "code_length_change": -177,
    "time_spent_seconds": 60.4,
    "time_spent": "1m 0s"
  }
}