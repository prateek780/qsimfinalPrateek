{
  "student_id": "prateek123",
  "protocol": "bb84",
  "snapshot_number": 8,
  "timestamp": "2025-10-13T11:46:14.822135",
  "time_since_last_change": 101.760564,
  "code": [
    "import random",
    "",
    "class StudentQuantumHost:",
    "    def __init__(self, name):",
    "        self.name = name",
    "        # Preparation (Alice) state",
    "        self.random_bits = []",
    "        self.preparation_bases = []",
    "        self.quantum_states = []",
    "        # Reception (Bob) state",
    "        self.received_bases = []",
    "        self.measurement_outcomes = []",
    "        # Compatibility / utility",
    "        self.sent_bits = []",
    "        self.prepared_qubits = []",
    "        self.sifted_key = []",
    "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
    "",
    "    def bb84_send_qubits(self, num_qubits):",
    "        print(f\"{self.name} is preparing {num_qubits} qubits...\")",
    "        # ensure/reset preparation containers",
    "        self.random_bits = []",
    "        self.preparation_bases = []",
    "        self.quantum_states = []",
    "",
    "        for _ in range(num_qubits):",
    "            classical_bit = random.randint(0, 1)",
    "            preparation_basis = random.randint(0, 1)",
    "            if preparation_basis == 0:",
    "                quantum_state = \"|0⟩\" if classical_bit == 0 else \"|1⟩\"",
    "            else:",
    "                quantum_state = \"|+⟩\" if classical_bit == 0 else \"|-⟩\"",
    "",
    "            self.random_bits.append(classical_bit)",
    "            self.preparation_bases.append(preparation_basis)",
    "            self.quantum_states.append(quantum_state)",
    "",
    "        print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
    "        return self.quantum_states",
    "",
    "    def process_received_qbit(self, qbit, from_channel=None):",
    "        measurement_basis = random.randint(0, 1)",
    "        self.received_bases.append(measurement_basis)",
    "",
    "        if measurement_basis == 0:",
    "            # Z-basis measurement",
    "            if qbit == \"|0⟩\":",
    "                outcome = 0",
    "            elif qbit == \"|1⟩\":",
    "                outcome = 1",
    "            elif qbit in (\"|+⟩\", \"|-⟩\"):",
    "                outcome = random.randint(0, 1)",
    "            else:",
    "                outcome = random.randint(0, 1)",
    "        else:",
    "            # X-basis measurement",
    "            if qbit == \"|+⟩\":",
    "                outcome = 0",
    "            elif qbit == \"|-⟩\":",
    "                outcome = 1",
    "            elif qbit in (\"|0⟩\", \"|1⟩\"):",
    "                outcome = random.randint(0, 1)",
    "            else:",
    "                outcome = random.randint(0, 1)",
    "",
    "        self.measurement_outcomes.append(outcome)",
    "        print(f\"{self.name} measured a received qubit in {'Z' if measurement_basis==0 else 'X'}-basis -> outcome {outcome}\")",
    "        return True",
    "",
    "    def bb84_reconcile_bases(self, alice_bases, bob_bases):",
    "        print(f\"{self.name} is comparing basis choices...\")",
    "        matching_indices = []",
    "        corresponding_bits = []",
    "",
    "        for i, (a_b, b_b) in enumerate(zip(alice_bases, bob_bases)):",
    "            if a_b == b_b:",
    "                matching_indices.append(i)",
    "                if i < len(self.measurement_outcomes):",
    "                    corresponding_bits.append(self.measurement_outcomes[i])",
    "                elif i < len(self.random_bits):",
    "                    corresponding_bits.append(self.random_bits[i])",
    "",
    "        total_comparisons = min(len(alice_bases), len(bob_bases))",
    "        matches_found = len(matching_indices)",
    "        match_proportion = matches_found / total_comparisons if total_comparisons > 0 else 0.0",
    "",
    "        print(f\"Matches found: {matches_found} / {total_comparisons} ({match_proportion*100:.1f}%)\")",
    "        return matching_indices, corresponding_bits",
    "",
    "    def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
    "        print(f\"{self.name} is calculating error rate...\")",
    "        comparison_count = 0",
    "        error_count = 0",
    "",
    "        for pos, ref_bit in zip(sample_positions, reference_bits):",
    "            if 0 <= pos < len(self.measurement_outcomes):",
    "                comparison_count += 1",
    "                if self.measurement_outcomes[pos] != ref_bit:",
    "                    error_count += 1",
    "            elif 0 <= pos < len(self.random_bits):",
    "                comparison_count += 1",
    "                if self.random_bits[pos] != ref_bit:",
    "                    error_count += 1",
    "            else:",
    "                # invalid position, skip",
    "                continue",
    "",
    "        error_rate = error_count / comparison_count if comparison_count > 0 else 0.0",
    "        print(f\"Error rate: {error_rate*100:.2f}% ({error_count}/{comparison_count})\")",
    "        return error_rate"
  ],
  "code_length": 4271,
  "line_count": 110,
  "file_hash": "d136e4100a8173ade93035d9358bcbe9",
  "changes": {
    "lines_added": -89,
    "lines_removed": 89,
    "code_length_change": -3434,
    "time_spent_seconds": 101.8,
    "time_spent": "1m 41s"
  }
}