{
  "student_id": "prateektest123",
  "session_id": "YdyOpQlIHHECobfUy721",
  "session_start": "2025-10-22T16:00:17.890253",
  "activities": [
    {
      "protocol": "BB84",
      "timestamp": "2025-10-22T16:00:31.913809",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "# ",
        "import random",
        "",
        "class StudentQuantumHost:",
        "",
        "    def __init__(self, name):",
        "        self.name = name",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "        self.received_bases = []",
        "        self.measurement_outcomes = []",
        "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts an integer parameter specifying the quantity of qubits to prepare.",
        "        Print a message indicating the host is preparing this quantity of qubits.",
        "        Clear and reinitialize three instance lists: one for random bits, one for bases, and one for quantum states.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random bit (0 or 1)",
        "        - Generate a random basis (0 or 1)",
        "        - If basis is 0: encode bit 0 as \"|0⟩\" and bit 1 as \"|1⟩\"",
        "        - If basis is 1: encode bit 0 as \"|+⟩\" and bit 1 as \"|-⟩\"",
        "        - Append the random bit to the first list, the basis to the second list, and the encoded state to the third list",
        "        After processing all qubits, print a message showing how many qubits were prepared.",
        "        Return the list of encoded quantum states.",
        "        \"\"\"",
        "",
        "    def bb84_send_qubits(self, num_qubits):",
        "        print(f\"{self.name} is preparing {num_qubits} qubits...\")",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "",
        "        for _ in range(num_qubits):",
        "            bit = random.randint(0, 1)",
        "            basis = random.randint(0, 1)",
        "",
        "            if basis == 0:",
        "                state = \"|0⟩\" if bit == 0 else \"|1⟩\"",
        "            else:",
        "                state = \"|+⟩\" if bit == 0 else \"|-⟩\"",
        "",
        "            self.random_bits.append(bit)",
        "            self.measurement_bases.append(basis)",
        "            self.quantum_states.append(state)",
        "",
        "        print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
        "        return self.quantum_states",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a quantum state string and a channel reference.",
        "        Generate a random measurement basis (0 or 1) and append it to the received bases list.",
        "        Perform measurement based on the following rules:",
        "        - If measurement basis is 0 (rectilinear):",
        "      * State \"|0⟩\" yields outcome 0",
        "      * State \"|1⟩\" yields outcome 1",
        "      * States \"|+⟩\" or \"|-⟩\" yield random outcome (0 or 1)",
        "        - If measurement basis is 1 (diagonal):",
        "      * State \"|+⟩\" yields outcome 0",
        "      * State \"|-⟩\" yields outcome 1",
        "      * States \"|0⟩\" or \"|1⟩\" yield random outcome (0 or 1)",
        "        - For any other state, yield random outcome (0 or 1)",
        "        Append the measurement outcome to the measurement outcomes list.",
        "        Return True to indicate successful processing.",
        "",
        "        \"\"\"",
        "",
        "    def process_received_qbit(self, qbit, from_channel):",
        "        basis = random.randint(0, 1)",
        "        self.received_bases.append(basis)",
        "",
        "        if basis == 0:  # Rectilinear (Z) basis",
        "            if qbit == \"|0⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|1⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|+⟩\" or qbit == \"|-⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "        else:  # Diagonal (X) basis",
        "            if qbit == \"|+⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|-⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|0⟩\" or qbit == \"|1⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "",
        "        self.measurement_outcomes.append(outcome)",
        "        return True",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: both are lists of basis values representing sender and receiver bases.",
        "        Print a message indicating the host is comparing basis choices.",
        "        Create two empty lists: one for matching indices and one for corresponding bit values.",
        "        Iterate through both basis lists simultaneously with enumeration:",
        "        - For each index where both basis values are equal, append the index to the matching indices list",
        "        - If the index is valid for the measurement outcomes list, append the corresponding measurement outcome to the bits list",
        "        - Otherwise, if the index is valid for the random bits list, append the corresponding random bit to the bits list",
        "        Calculate total comparisons as the minimum length of the two basis lists.",
        "        Calculate the match proportion (matching count divided by total, or 0 if total is 0).",
        "        Print a message showing: \"Matches found: X / Y (Z%)\" where X is matches, Y is total, and Z is percentage with 1 decimal place.",
        "        Return both the matching indices list and the corresponding bits list.",
        "        \"\"\"",
        "",
        "        #def bb84_reconcile_bases(self, alice_bases, bob_bases):",
        "    def bb84_reconcile_bases(self, alice_bases, bob_bases):",
        "        print(f\"{self.name} is comparing basis choices...\")",
        "        matching_indices = []",
        "        corresponding_bits = []",
        "",
        "        for i, (alice_basis, bob_basis) in enumerate(zip(alice_bases, bob_bases)):",
        "        if alice_basis == bob_basis:",
        "            matching_indices.append(i)",
        "            if i < len(self.measurement_outcomes):",
        "                corresponding_bits.append(self.measurement_outcomes[i])",
        "            elif i < len(self.random_bits):",
        "                corresponding_bits.append(self.random_bits[i])",
        "",
        "        total_comparisons = min(len(alice_bases), len(bob_bases))",
        "        matches_found = len(matching_indices)",
        "        match_proportion = matches_found / total_comparisons if total_comparisons > 0 else 0",
        "",
        "        print(f\"Matches found: {matches_found} / {total_comparisons} ({match_proportion*100:.1f}%)\")",
        "        return matching_indices, corresponding_bits",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, if it's a valid index in the measurement outcomes list:",
        "      * Increment the comparison counter",
        "      * If the measurement outcome at that position doesn't match the reference bit, increment the error counter",
        "        - Otherwise, if the position is valid in the random bits list:",
        "      * Increment the comparison counter",
        "      * If the random bit at that position doesn't match the reference bit, increment the error counter",
        "        Calculate the error rate as errors divided by comparisons (or 0.0 if comparisons is 0).",
        "        Print a message showing: \"Error rate: X% (Y/Z)\" where X is the rate as percentage with 2 decimals, Y is error count, Z is comparison count.",
        "        Return the calculated error rate.",
        "        \"\"\"",
        "        \"\"\"",
        "        #def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        "    def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        "        print(f\"{self.name} is calculating error rate...\")",
        "        comparison_count = 0",
        "        error_count = 0",
        "",
        "        for position, reference_bit in zip(sample_positions, reference_bits):",
        "        if position < len(self.measurement_outcomes):",
        "            comparison_count += 1",
        "            if self.measurement_outcomes[position] != reference_bit:",
        "                error_count += 1",
        "        elif position < len(self.random_bits):",
        "            comparison_count += 1",
        "            if self.random_bits[position] != reference_bit:",
        "                error_count += 1",
        "",
        "        error_rate = error_count / comparison_count if comparison_count > 0 else 0.0",
        "        print(f\"Error rate: {error_rate*100:.2f}% ({error_count}/{comparison_count})\")",
        "        return error_rate",
        "",
        "        \"\"\"",
        ""
      ],
      "output": "",
      "code_length": 7844,
      "line_count": 169
    },
    {
      "protocol": "BB84",
      "timestamp": "2025-10-22T16:05:33.445050",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "# ",
        "import random",
        "",
        "class StudentQuantumHost:",
        "",
        "    def __init__(self, name):",
        "        self.name = name",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "        self.received_bases = []",
        "        self.measurement_outcomes = []",
        "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts an integer parameter specifying the quantity of qubits to prepare.",
        "        Print a message indicating the host is preparing this quantity of qubits.",
        "        Clear and reinitialize three instance lists: one for random bits, one for bases, and one for quantum states.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random bit (0 or 1)",
        "        - Generate a random basis (0 or 1)",
        "        - If basis is 0: encode bit 0 as \"|0⟩\" and bit 1 as \"|1⟩\"",
        "        - If basis is 1: encode bit 0 as \"|+⟩\" and bit 1 as \"|-⟩\"",
        "        - Append the random bit to the first list, the basis to the second list, and the encoded state to the third list",
        "        After processing all qubits, print a message showing how many qubits were prepared.",
        "        Return the list of encoded quantum states.",
        "        \"\"\"",
        "",
        "    def bb84_send_qubits(self, num_qubits):",
        "        print(f\"{self.name} is preparing {num_qubits} qubits...\")",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "",
        "        for _ in range(num_qubits):",
        "            bit = random.randint(0, 1)",
        "            basis = random.randint(0, 1)",
        "",
        "            if basis == 0:",
        "                state = \"|0⟩\" if bit == 0 else \"|1⟩\"",
        "            else:",
        "                state = \"|+⟩\" if bit == 0 else \"|-⟩\"",
        "",
        "            self.random_bits.append(bit)",
        "            self.measurement_bases.append(basis)",
        "            self.quantum_states.append(state)",
        "",
        "        print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
        "        return self.quantum_states",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a quantum state string and a channel reference.",
        "        Generate a random measurement basis (0 or 1) and append it to the received bases list.",
        "        Perform measurement based on the following rules:",
        "        - If measurement basis is 0 (rectilinear):",
        "      * State \"|0⟩\" yields outcome 0",
        "      * State \"|1⟩\" yields outcome 1",
        "      * States \"|+⟩\" or \"|-⟩\" yield random outcome (0 or 1)",
        "        - If measurement basis is 1 (diagonal):",
        "      * State \"|+⟩\" yields outcome 0",
        "      * State \"|-⟩\" yields outcome 1",
        "      * States \"|0⟩\" or \"|1⟩\" yield random outcome (0 or 1)",
        "        - For any other state, yield random outcome (0 or 1)",
        "        Append the measurement outcome to the measurement outcomes list.",
        "        Return True to indicate successful processing.",
        "",
        "        \"\"\"",
        "",
        "    def process_received_qbit(self, qbit, from_channel):",
        "        basis = random.randint(0, 1)",
        "        self.received_bases.append(basis)",
        "",
        "        if basis == 0:  # Rectilinear (Z) basis",
        "            if qbit == \"|0⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|1⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|+⟩\" or qbit == \"|-⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "        else:  # Diagonal (X) basis",
        "            if qbit == \"|+⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|-⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|0⟩\" or qbit == \"|1⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "",
        "        self.measurement_outcomes.append(outcome)",
        "        return True",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: both are lists of basis values representing sender and receiver bases.",
        "        Print a message indicating the host is comparing basis choices.",
        "        Create two empty lists: one for matching indices and one for corresponding bit values.",
        "        Iterate through both basis lists simultaneously with enumeration:",
        "        - For each index where both basis values are equal, append the index to the matching indices list",
        "        - If the index is valid for the measurement outcomes list, append the corresponding measurement outcome to the bits list",
        "        - Otherwise, if the index is valid for the random bits list, append the corresponding random bit to the bits list",
        "        Calculate total comparisons as the minimum length of the two basis lists.",
        "        Calculate the match proportion (matching count divided by total, or 0 if total is 0).",
        "        Print a message showing: \"Matches found: X / Y (Z%)\" where X is matches, Y is total, and Z is percentage with 1 decimal place.",
        "        Return both the matching indices list and the corresponding bits list.",
        "        \"\"\"",
        "",
        "        #def bb84_reconcile_bases(self, alice_bases, bob_bases):",
        "    def bb84_reconcile_bases(self, alice_bases, bob_bases):",
        "        print(f\"{self.name} is comparing basis choices...\")",
        "        matching_indices = []",
        "        corresponding_bits = []",
        "",
        "        for i, (alice_basis, bob_basis) in enumerate(zip(alice_bases, bob_bases)):",
        "        if alice_basis == bob_basis:",
        "            matching_indices.append(i)",
        "            if i < len(self.measurement_outcomes):",
        "                corresponding_bits.append(self.measurement_outcomes[i])",
        "            elif i < len(self.random_bits):",
        "                corresponding_bits.append(self.random_bits[i])",
        "",
        "        total_comparisons = min(len(alice_bases), len(bob_bases))",
        "        matches_found = len(matching_indices)",
        "        match_proportion = matches_found / total_comparisons if total_comparisons > 0 else 0",
        "",
        "        print(f\"Matches found: {matches_found} / {total_comparisons} ({match_proportion*100:.1f}%)\")",
        "        return matching_indices, corresponding_bits",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, if it's a valid index in the measurement outcomes list:",
        "      * Increment the comparison counter",
        "      * If the measurement outcome at that position doesn't match the reference bit, increment the error counter",
        "        - Otherwise, if the position is valid in the random bits list:",
        "      * Increment the comparison counter",
        "      * If the random bit at that position doesn't match the reference bit, increment the error counter",
        "        Calculate the error rate as errors divided by comparisons (or 0.0 if comparisons is 0).",
        "        Print a message showing: \"Error rate: X% (Y/Z)\" where X is the rate as percentage with 2 decimals, Y is error count, Z is comparison count.",
        "        Return the calculated error rate.",
        "        \"\"\"",
        "",
        "        #def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        "        \"\"\"",
        "    def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        "        print(f\"{self.name} is calculating error rate...\")",
        "        comparison_count = 0",
        "        error_count = 0",
        "",
        "        for position, reference_bit in zip(sample_positions, reference_bits):",
        "        if position < len(self.measurement_outcomes):",
        "            comparison_count += 1",
        "            if self.measurement_outcomes[position] != reference_bit:",
        "                error_count += 1",
        "        elif position < len(self.random_bits):",
        "            comparison_count += 1",
        "            if self.random_bits[position] != reference_bit:",
        "                error_count += 1",
        "",
        "        error_rate = error_count / comparison_count if comparison_count > 0 else 0.0",
        "        print(f\"Error rate: {error_rate*100:.2f}% ({error_count}/{comparison_count})\")",
        "        return error_rate",
        "",
        "        \"\"\"",
        ""
      ],
      "output": "",
      "code_length": 7845,
      "line_count": 170
    }
  ],
  "firebase_enabled": true,
  "last_updated": "2025-10-22T16:05:33.445100"
}