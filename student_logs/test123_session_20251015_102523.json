{
  "student_id": "test123",
  "session_id": "VDGU8ClPTcP8MkG8iBJl",
  "session_start": "2025-10-15T10:25:23.918449",
  "activities": [
    {
      "protocol": "BB84",
      "timestamp": "2025-10-15T10:35:27.712848",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "# ",
        "import random",
        "",
        "class StudentQuantumHost:",
        "",
        "    def __init__(self, name):",
        "        self.name = name",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "        self.received_bases = []",
        "        self.measurement_outcomes = []",
        "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts an integer parameter specifying the quantity of qubits to prepare.",
        "        Print a message indicating the host is preparing this quantity of qubits.",
        "        Clear and reinitialize three instance lists: one for random bits, one for bases, and one for quantum states.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random bit (0 or 1)",
        "        - Generate a random basis (0 or 1)",
        "        - If basis is 0: encode bit 0 as \"|0⟩\" and bit 1 as \"|1⟩\"",
        "        - If basis is 1: encode bit 0 as \"|+⟩\" and bit 1 as \"|-⟩\"",
        "        - Append the random bit to the first list, the basis to the second list, and the encoded state to the third list",
        "        After processing all qubits, print a message showing how many qubits were prepared.",
        "        Return the list of encoded quantum states.",
        "        \"\"\"",
        "",
        "    def bb84_send_qubits(self, num_qubits):",
        "        print(f\"{self.name} is preparing {num_qubits} qubits...\")",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "",
        "        for _ in range(num_qubits):",
        "            bit = random.randint(0, 1)",
        "            basis = random.randint(0, 1)",
        "",
        "            if basis == 0:",
        "                state = \"|0⟩\" if bit == 0 else \"|1⟩\"",
        "            else:",
        "                state = \"|+⟩\" if bit == 0 else \"|-⟩\"",
        "",
        "            self.random_bits.append(bit)",
        "            self.measurement_bases.append(basis)",
        "            self.quantum_states.append(state)",
        "",
        "        print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
        "        return self.quantum_states",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a quantum state string and a channel reference.",
        "        Generate a random measurement basis (0 or 1) and append it to the received bases list.",
        "        Perform measurement based on the following rules:",
        "        - If measurement basis is 0 (rectilinear):",
        "      * State \"|0⟩\" yields outcome 0",
        "      * State \"|1⟩\" yields outcome 1",
        "      * States \"|+⟩\" or \"|-⟩\" yield random outcome (0 or 1)",
        "        - If measurement basis is 1 (diagonal):",
        "      * State \"|+⟩\" yields outcome 0",
        "      * State \"|-⟩\" yields outcome 1",
        "      * States \"|0⟩\" or \"|1⟩\" yield random outcome (0 or 1)",
        "        - For any other state, yield random outcome (0 or 1)",
        "        Append the measurement outcome to the measurement outcomes list.",
        "        Return True to indicate successful processing.",
        "",
        "        \"\"\"",
        "",
        "    def process_received_qbit(self, qbit, from_channel):",
        "        basis = random.randint(0, 1)",
        "        self.received_bases.append(basis)",
        "",
        "        if basis == 0:  # Rectilinear (Z) basis",
        "            if qbit == \"|0⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|1⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|+⟩\" or qbit == \"|-⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "        else:  # Diagonal (X) basis",
        "            if qbit == \"|+⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|-⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|0⟩\" or qbit == \"|1⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "",
        "        self.measurement_outcomes.append(outcome)",
        "        return True",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: both are lists of basis values representing sender and receiver bases.",
        "        Print a message indicating the host is comparing basis choices.",
        "        Create two empty lists: one for matching indices and one for corresponding bit values.",
        "        Iterate through both basis lists simultaneously with enumeration:",
        "        - For each index where both basis values are equal, append the index to the matching indices list",
        "        - If the index is valid for the measurement outcomes list, append the corresponding measurement outcome to the bits list",
        "        - Otherwise, if the index is valid for the random bits list, append the corresponding random bit to the bits list",
        "        Calculate total comparisons as the minimum length of the two basis lists.",
        "        Calculate the match proportion (matching count divided by total, or 0 if total is 0).",
        "        Print a message showing: \"Matches found: X / Y (Z%)\" where X is matches, Y is total, and Z is percentage with 1 decimal place.",
        "        Return both the matching indices list and the corresponding bits list.",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, if it's a valid index in the measurement outcomes list:",
        "      * Increment the comparison counter",
        "      * If the measurement outcome at that position doesn't match the reference bit, increment the error counter",
        "        - Otherwise, if the position is valid in the random bits list:",
        "      * Increment the comparison counter",
        "      * If the random bit at that position doesn't match the reference bit, increment the error counter",
        "        Calculate the error rate as errors divided by comparisons (or 0.0 if comparisons is 0).",
        "        Print a message showing: \"Error rate: X% (Y/Z)\" where X is the rate as percentage with 2 decimals, Y is error count, Z is comparison count.",
        "        Return the calculated error rate.",
        "        \"\"\"",
        "",
        "        #def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        ""
      ],
      "output": "",
      "code_length": 5969,
      "line_count": 125
    },
    {
      "protocol": "BB84",
      "timestamp": "2025-10-15T10:36:56.917057",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "# ",
        "import random",
        "",
        "class StudentQuantumHost:",
        "",
        "    def __init__(self, name):",
        "        self.name = name",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "        self.received_bases = []",
        "        self.measurement_outcomes = []",
        "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts an integer parameter specifying the quantity of qubits to prepare.",
        "        Print a message indicating the host is preparing this quantity of qubits.",
        "        Clear and reinitialize three instance lists: one for random bits, one for bases, and one for quantum states.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random bit (0 or 1)",
        "        - Generate a random basis (0 or 1)",
        "        - If basis is 0: encode bit 0 as \"|0⟩\" and bit 1 as \"|1⟩\"",
        "        - If basis is 1: encode bit 0 as \"|+⟩\" and bit 1 as \"|-⟩\"",
        "        - Append the random bit to the first list, the basis to the second list, and the encoded state to the third list",
        "        After processing all qubits, print a message showing how many qubits were prepared.",
        "        Return the list of encoded quantum states.",
        "        \"\"\"",
        "",
        "    def bb84_send_qubits(self, num_qubits):",
        "        print(f\"{self.name} is preparing {num_qubits} qubits...\")",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "",
        "        for _ in range(num_qubits):",
        "            bit = random.randint(0, 1)",
        "            basis = random.randint(0, 1)",
        "",
        "            if basis == 0:",
        "                state = \"|0⟩\" if bit == 0 else \"|1⟩\"",
        "            else:",
        "                state = \"|+⟩\" if bit == 0 else \"|-⟩\"",
        "",
        "            self.random_bits.append(bit)",
        "            self.measurement_bases.append(basis)",
        "            self.quantum_states.append(state)",
        "",
        "        print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
        "        return self.quantum_states",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a quantum state string and a channel reference.",
        "        Generate a random measurement basis (0 or 1) and append it to the received bases list.",
        "        Perform measurement based on the following rules:",
        "        - If measurement basis is 0 (rectilinear):",
        "      * State \"|0⟩\" yields outcome 0",
        "      * State \"|1⟩\" yields outcome 1",
        "      * States \"|+⟩\" or \"|-⟩\" yield random outcome (0 or 1)",
        "        - If measurement basis is 1 (diagonal):",
        "      * State \"|+⟩\" yields outcome 0",
        "      * State \"|-⟩\" yields outcome 1",
        "      * States \"|0⟩\" or \"|1⟩\" yield random outcome (0 or 1)",
        "        - For any other state, yield random outcome (0 or 1)",
        "        Append the measurement outcome to the measurement outcomes list.",
        "        Return True to indicate successful processing.",
        "",
        "        \"\"\"",
        "",
        "    def process_received_qbit(self, qbit, from_channel):",
        "        basis = random.randint(0, 1)",
        "        self.received_bases.append(basis)",
        "",
        "        if basis == 0:  # Rectilinear (Z) basis",
        "            if qbit == \"|0⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|1⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|+⟩\" or qbit == \"|-⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "        else:  # Diagonal (X) basis",
        "            if qbit == \"|+⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|-⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|0⟩\" or qbit == \"|1⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "",
        "        self.measurement_outcomes.append(outcome)",
        "        return True",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: both are lists of basis values representing sender and receiver bases.",
        "        Print a message indicating the host is comparing basis choices.",
        "        Create two empty lists: one for matching indices and one for corresponding bit values.",
        "        Iterate through both basis lists simultaneously with enumeration:",
        "        - For each index where both basis values are equal, append the index to the matching indices list",
        "        - If the index is valid for the measurement outcomes list, append the corresponding measurement outcome to the bits list",
        "        - Otherwise, if the index is valid for the random bits list, append the corresponding random bit to the bits list",
        "        Calculate total comparisons as the minimum length of the two basis lists.",
        "        Calculate the match proportion (matching count divided by total, or 0 if total is 0).",
        "        Print a message showing: \"Matches found: X / Y (Z%)\" where X is matches, Y is total, and Z is percentage with 1 decimal place.",
        "        Return both the matching indices list and the corresponding bits list.",
        "        \"\"\"",
        "",
        "        #def bb84_reconcile_bases(self, alice_bases, bob_bases):",
        "    def bb84_reconcile_bases(self, alice_bases, bob_bases):",
        "        print(f\"{self.name} is comparing basis choices...\")",
        "        matching_indices = []",
        "        corresponding_bits = []",
        "",
        "        for i, (alice_basis, bob_basis) in enumerate(zip(alice_bases, bob_bases)):",
        "        if alice_basis == bob_basis:",
        "            matching_indices.append(i)",
        "            if i < len(self.measurement_outcomes):",
        "                corresponding_bits.append(self.measurement_outcomes[i])",
        "            elif i < len(self.random_bits):",
        "                corresponding_bits.append(self.random_bits[i])",
        "",
        "        total_comparisons = min(len(alice_bases), len(bob_bases))",
        "        matches_found = len(matching_indices)",
        "        match_proportion = matches_found / total_comparisons if total_comparisons > 0 else 0",
        "",
        "        print(f\"Matches found: {matches_found} / {total_comparisons} ({match_proportion*100:.1f}%)\")",
        "        return matching_indices, corresponding_bits",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, if it's a valid index in the measurement outcomes list:",
        "      * Increment the comparison counter",
        "      * If the measurement outcome at that position doesn't match the reference bit, increment the error counter",
        "        - Otherwise, if the position is valid in the random bits list:",
        "      * Increment the comparison counter",
        "      * If the random bit at that position doesn't match the reference bit, increment the error counter",
        "        Calculate the error rate as errors divided by comparisons (or 0.0 if comparisons is 0).",
        "        Print a message showing: \"Error rate: X% (Y/Z)\" where X is the rate as percentage with 2 decimals, Y is error count, Z is comparison count.",
        "        Return the calculated error rate.",
        "        \"\"\"",
        "",
        "        #def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        ""
      ],
      "output": "",
      "code_length": 6992,
      "line_count": 149
    },
    {
      "protocol": "BB84",
      "timestamp": "2025-10-15T10:37:56.164264",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "# ",
        "import random",
        "",
        "class StudentQuantumHost:",
        "",
        "    def __init__(self, name):",
        "        self.name = name",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "        self.received_bases = []",
        "        self.measurement_outcomes = []",
        "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts an integer parameter specifying the quantity of qubits to prepare.",
        "        Print a message indicating the host is preparing this quantity of qubits.",
        "        Clear and reinitialize three instance lists: one for random bits, one for bases, and one for quantum states.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random bit (0 or 1)",
        "        - Generate a random basis (0 or 1)",
        "        - If basis is 0: encode bit 0 as \"|0⟩\" and bit 1 as \"|1⟩\"",
        "        - If basis is 1: encode bit 0 as \"|+⟩\" and bit 1 as \"|-⟩\"",
        "        - Append the random bit to the first list, the basis to the second list, and the encoded state to the third list",
        "        After processing all qubits, print a message showing how many qubits were prepared.",
        "        Return the list of encoded quantum states.",
        "        \"\"\"",
        "",
        "    def bb84_send_qubits(self, num_qubits):",
        "        print(f\"{self.name} is preparing {num_qubits} qubits...\")",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "",
        "        for _ in range(num_qubits):",
        "            bit = random.randint(0, 1)",
        "            basis = random.randint(0, 1)",
        "",
        "            if basis == 0:",
        "                state = \"|0⟩\" if bit == 0 else \"|1⟩\"",
        "            else:",
        "                state = \"|+⟩\" if bit == 0 else \"|-⟩\"",
        "",
        "            self.random_bits.append(bit)",
        "            self.measurement_bases.append(basis)",
        "            self.quantum_states.append(state)",
        "",
        "        print(f\"{self.name} prepared {len(self.quantum_states)} qubits\")",
        "        return self.quantum_states",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a quantum state string and a channel reference.",
        "        Generate a random measurement basis (0 or 1) and append it to the received bases list.",
        "        Perform measurement based on the following rules:",
        "        - If measurement basis is 0 (rectilinear):",
        "      * State \"|0⟩\" yields outcome 0",
        "      * State \"|1⟩\" yields outcome 1",
        "      * States \"|+⟩\" or \"|-⟩\" yield random outcome (0 or 1)",
        "        - If measurement basis is 1 (diagonal):",
        "      * State \"|+⟩\" yields outcome 0",
        "      * State \"|-⟩\" yields outcome 1",
        "      * States \"|0⟩\" or \"|1⟩\" yield random outcome (0 or 1)",
        "        - For any other state, yield random outcome (0 or 1)",
        "        Append the measurement outcome to the measurement outcomes list.",
        "        Return True to indicate successful processing.",
        "",
        "        \"\"\"",
        "",
        "    def process_received_qbit(self, qbit, from_channel):",
        "        basis = random.randint(0, 1)",
        "        self.received_bases.append(basis)",
        "",
        "        if basis == 0:  # Rectilinear (Z) basis",
        "            if qbit == \"|0⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|1⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|+⟩\" or qbit == \"|-⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "        else:  # Diagonal (X) basis",
        "            if qbit == \"|+⟩\":",
        "                outcome = 0",
        "            elif qbit == \"|-⟩\":",
        "                outcome = 1",
        "            elif qbit == \"|0⟩\" or qbit == \"|1⟩\":",
        "                outcome = random.randint(0, 1)",
        "            else:",
        "                outcome = random.randint(0, 1)",
        "",
        "        self.measurement_outcomes.append(outcome)",
        "        return True",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: both are lists of basis values representing sender and receiver bases.",
        "        Print a message indicating the host is comparing basis choices.",
        "        Create two empty lists: one for matching indices and one for corresponding bit values.",
        "        Iterate through both basis lists simultaneously with enumeration:",
        "        - For each index where both basis values are equal, append the index to the matching indices list",
        "        - If the index is valid for the measurement outcomes list, append the corresponding measurement outcome to the bits list",
        "        - Otherwise, if the index is valid for the random bits list, append the corresponding random bit to the bits list",
        "        Calculate total comparisons as the minimum length of the two basis lists.",
        "        Calculate the match proportion (matching count divided by total, or 0 if total is 0).",
        "        Print a message showing: \"Matches found: X / Y (Z%)\" where X is matches, Y is total, and Z is percentage with 1 decimal place.",
        "        Return both the matching indices list and the corresponding bits list.",
        "        \"\"\"",
        "",
        "        #def bb84_reconcile_bases(self, alice_bases, bob_bases):",
        "    def bb84_reconcile_bases(self, alice_bases, bob_bases):",
        "        print(f\"{self.name} is comparing basis choices...\")",
        "        matching_indices = []",
        "        corresponding_bits = []",
        "",
        "        for i, (alice_basis, bob_basis) in enumerate(zip(alice_bases, bob_bases)):",
        "        if alice_basis == bob_basis:",
        "            matching_indices.append(i)",
        "            if i < len(self.measurement_outcomes):",
        "                corresponding_bits.append(self.measurement_outcomes[i])",
        "            elif i < len(self.random_bits):",
        "                corresponding_bits.append(self.random_bits[i])",
        "",
        "        total_comparisons = min(len(alice_bases), len(bob_bases))",
        "        matches_found = len(matching_indices)",
        "        match_proportion = matches_found / total_comparisons if total_comparisons > 0 else 0",
        "",
        "        print(f\"Matches found: {matches_found} / {total_comparisons} ({match_proportion*100:.1f}%)\")",
        "        return matching_indices, corresponding_bits",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, if it's a valid index in the measurement outcomes list:",
        "      * Increment the comparison counter",
        "      * If the measurement outcome at that position doesn't match the reference bit, increment the error counter",
        "        - Otherwise, if the position is valid in the random bits list:",
        "      * Increment the comparison counter",
        "      * If the random bit at that position doesn't match the reference bit, increment the error counter",
        "        Calculate the error rate as errors divided by comparisons (or 0.0 if comparisons is 0).",
        "        Print a message showing: \"Error rate: X% (Y/Z)\" where X is the rate as percentage with 2 decimals, Y is error count, Z is comparison count.",
        "        Return the calculated error rate.",
        "        \"\"\"",
        "",
        "        #def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        "    def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        "        print(f\"{self.name} is calculating error rate...\")",
        "        comparison_count = 0",
        "        error_count = 0",
        "",
        "        for position, reference_bit in zip(sample_positions, reference_bits):",
        "        if position < len(self.measurement_outcomes):",
        "            comparison_count += 1",
        "            if self.measurement_outcomes[position] != reference_bit:",
        "                error_count += 1",
        "        elif position < len(self.random_bits):",
        "            comparison_count += 1",
        "            if self.random_bits[position] != reference_bit:",
        "                error_count += 1",
        "",
        "        error_rate = error_count / comparison_count if comparison_count > 0 else 0.0",
        "        print(f\"Error rate: {error_rate*100:.2f}% ({error_count}/{comparison_count})\")",
        "        return error_rate",
        ""
      ],
      "output": "",
      "code_length": 7820,
      "line_count": 167
    },
    {
      "protocol": "B92",
      "timestamp": "2025-10-15T10:40:40.582935",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "import random",
        "",
        "class StudentB92Host:",
        "    # Student's B92 QKD implementation class with instance methods.",
        "    # All prompts are included above their respective implementations.",
        "    #",
        "    # B92 Protocol Summary:",
        "    # - Alice encodes: bit 0 -> |0⟩, bit 1 -> |+⟩ = (|0⟩ + |1⟩)/√2",
        "    # - Bob measures randomly in Z or X basis",
        "    # - Bob keeps only results where he measures |1⟩ (outcome = 1)",
        "    # - If Bob measures |1⟩ in Z basis -> Alice sent |+⟩ (bit 1)",
        "    # - If Bob measures |1⟩ in X basis -> Alice sent |0⟩ (bit 0)",
        "",
        "    def __init__(self, name):",
        "        \"\"\"",
        "        Initialize a StudentB92Host instance for the B92 protocol.",
        "",
        "        Args:",
        "            name (str): The name of the host (e.g., 'Alice' or 'Bob')",
        "        \"\"\"",
        "        # Store the host name for logging purposes",
        "        self.name = name",
        "",
        "        # Initialize empty lists for B92 protocol state tracking",
        "        self.sent_bits = []  # Bits that were sent",
        "        self.prepared_qubits = []  # Prepared quantum states",
        "        self.received_measurements = []  # Measurements received",
        "        self.sifted_key = []  # Final sifted key after reconciliation",
        "        self.random_bits = []  # Random bits generated",
        "        self.measurement_outcomes = []  # Measurement results obtained",
        "        self.received_bases = []  # Bases used for receiving qubits",
        "",
        "        # Print initialization message",
        "        print(f\"StudentB92Host '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts a single binary value (0 or 1) as input.",
        "        Validate that the input is either 0 or 1; if not, raise a ValueError with an appropriate message.",
        "        Map the binary value to a quantum state using the following encoding:",
        "        - If the value is 0, return the state string \"|0⟩\"",
        "        - If the value is 1, return the state string \"|+⟩\"",
        "        Return the prepared quantum state string.",
        "",
        "    def b92_prepare_qubit(self, bit):",
        "",
        "        Prepare a qubit based on a classical bit following the B92 protocol.",
        "",
        "        Args:",
        "            bit (int): Classical bit value (0 or 1)",
        "",
        "        Returns:",
        "            str: Prepared quantum state ('|0⟩' or '|+⟩')",
        "",
        "        Raises:",
        "            ValueError: If bit is not 0 or 1",
        "",
        "        # Validate input bit",
        "        if bit not in [0, 1]:",
        "            raise ValueError(f\"Invalid bit value: {bit}. Must be 0 or 1.\")",
        "",
        "        # Map bit to non-orthogonal quantum state (B92 encoding)",
        "        if bit == 0:",
        "            qubit = '|0⟩'  # Bit 0 maps to |0⟩ state",
        "        else:  # bit == 1",
        "            qubit = '|+⟩'  # Bit 1 maps to |+⟩ superposition state",
        "",
        "        # Return the prepared qubit",
        "        return qubit",
        "",
        "        Create a method that accepts a quantum state string as input.",
        "        Randomly select a measurement basis from two options: \"Z\" or \"X\".",
        "        Perform measurement following these rules:",
        "        - If the selected basis is \"Z\":",
        "      * If the state is '|0⟩', set outcome to 0 (deterministic)",
        "      * If the state is '|+⟩', set outcome to a random value (0 or 1 with equal probability)",
        "      * For any other state, set outcome to a random value (0 or 1)",
        "        - If the selected basis is \"X\":",
        "      * If the state is '|+⟩', set outcome to 0 (deterministic)",
        "      * If the state is '|0⟩', set outcome to a random value (0 or 1 with equal probability)",
        "      * For any other state, set outcome to a random value (0 or 1)",
        "        Return a tuple containing the measurement outcome and the selected basis.",
        "",
        "    def b92_measure_qubit(self, qubit):",
        "",
        "        Measure a qubit in a randomly chosen basis following B92 protocol.",
        "",
        "        Args:",
        "            qubit (str): Quantum state to measure ('|0⟩' or '|+⟩')",
        "",
        "        Returns:",
        "            tuple: (outcome, basis) - measurement outcome (0 or 1) and basis used (\"Z\" or \"X\")",
        "",
        "        # Randomly choose measurement basis",
        "        basis = random.choice([\"Z\", \"X\"])",
        "",
        "        # Perform measurement based on chosen basis",
        "        if basis == \"Z\":  # Measuring in Z (computational) basis",
        "            if qubit == '|0⟩':",
        "                outcome = 0  # |0⟩ in Z basis: deterministic outcome 0",
        "            elif qubit == '|+⟩':",
        "                outcome = random.randint(0, 1)  # |+⟩ in Z basis: 50% probability for 0 or 1",
        "            else:",
        "                # Handle other states if present",
        "                outcome = random.randint(0, 1)",
        "",
        "        else:  # basis == \"X\" - Measuring in X (Hadamard) basis",
        "            if qubit == '|+⟩':",
        "                outcome = 0  # |+⟩ in X basis: deterministic outcome 0 (+1 eigenstate)",
        "            elif qubit == '|0⟩':",
        "                outcome = random.randint(0, 1)  # |0⟩ in X basis: 50% probability for 0 or 1",
        "            else:",
        "                # Handle other states if present",
        "                outcome = random.randint(0, 1)",
        "",
        "        # Return both outcome and basis",
        "        return outcome, basis",
        "        Create a method that accepts two parameters: a list of transmitted bits and a list of measurement tuples (each containing an outcome and a basis).",
        "        Print a message indicating the host is performing sifting.",
        "        Initialize two empty lists: one for storing indices of conclusive results and one for storing the sifted key bits.",
        "        Iterate through the measurement tuples with enumeration to track positions:",
        "        - For each tuple where the outcome equals 1 (conclusive result):",
        "      * Append the current index to the indices list",
        "      * If the basis is \"Z\", append bit value 1 to the sifted key list",
        "      * If the basis is \"X\", append bit value 0 to the sifted key list",
        "        Store the sifted key list in the instance variable for future use.",
        "        Calculate the total number of measurements and the count of conclusive results.",
        "        Calculate the sifting efficiency as the ratio of conclusive results to total measurements (or 0 if total is 0).",
        "        Print a summary showing: total measurements, conclusive results count, sifting efficiency as a percentage with 2 decimals, and the first 10 bits of the sifted key.",
        "        Return a tuple containing the indices list and the sifted key list.",
        "",
        "    def b92_sifting(self, sent_bits, received_measurements):",
        "",
        "        Perform sifting stage of B92 protocol by keeping only conclusive measurements.",
        "",
        "        Args:",
        "            sent_bits (list): Bits that were sent by Alice",
        "            received_measurements (list): List of (outcome, basis) tuples from Bob's measurements",
        "",
        "        Returns:",
        "            tuple: (sifted_indices, sifted_key) - indices of conclusive results and corresponding bits",
        "",
        "        print(f\"\\n{self.name} is performing B92 sifting...\")",
        "",
        "        # Initialize collections for sifted data",
        "        sifted_indices = []",
        "        sifted_key = []",
        "",
        "        # Iterate through received measurements with their positions",
        "        for index, (outcome, basis) in enumerate(received_measurements):",
        "            # Keep only conclusive outcomes (result = 1)",
        "            if outcome == 1:",
        "                # Record the index of this conclusive measurement",
        "                sifted_indices.append(index)",
        "",
        "                # Determine the bit based on basis used",
        "                if basis == \"Z\":",
        "                    # In Z basis: outcome 1 conclusively indicates sender sent |+⟩ (bit 1)",
        "                    bit = 1",
        "                else:  # basis == \"X\"",
        "                    # In X basis: outcome 1 conclusively indicates sender sent |0⟩ (bit 0)",
        "                    bit = 0",
        "",
        "                # Add the determined bit to sifted key",
        "                sifted_key.append(bit)",
        "",
        "        # Store sifted key for future use",
        "        self.sifted_key = sifted_key",
        "",
        "        # Display sifting summary",
        "        total_measurements = len(received_measurements)",
        "        conclusive_count = len(sifted_key)",
        "        sifting_efficiency = conclusive_count / total_measurements if total_measurements > 0 else 0",
        "",
        "        print(f\"Total measurements: {total_measurements}\")",
        "        print(f\"Conclusive results: {conclusive_count}\")",
        "        print(f\"Sifting efficiency: {sifting_efficiency:.2%}\")",
        "        print(f\"Sifted key (first 10): {sifted_key[:10]}\")",
        "",
        "        # Return sifted indices and key",
        "        return sifted_indices, sifted_key",
        "",
        "        Create a method that accepts an integer parameter specifying how many qubits to generate.",
        "        Print a message indicating the host is preparing to send the specified number of qubits.",
        "        Clear and reinitialize two instance lists: one for transmitted bits and one for prepared qubits.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random binary value (0 or 1)",
        "        - Append this value to the transmitted bits list",
        "        - Call the preparation method with this binary value to get a quantum state",
        "        - Append the returned quantum state to the prepared qubits list",
        "        After processing all qubits, print a success message showing how many qubits were prepared.",
        "        Print the first 10 elements of the transmitted bits list with a label.",
        "        Print the first 10 elements of the prepared qubits list with a label.",
        "        Return the list of prepared quantum states.",
        "",
        "    def b92_send_qubits(self, num_qubits):",
        "",
        "        Generate random bits and prepare qubits for transmission using B92 protocol.",
        "",
        "        Args:",
        "            num_qubits (int): Number of qubits to prepare and send",
        "",
        "        Returns:",
        "            list: List of prepared quantum states",
        "",
        "        print(f\"\\n{self.name} is preparing to send {num_qubits} qubits using B92 protocol...\")",
        "",
        "        # Initialize/reset internal storage",
        "        self.sent_bits = []",
        "        self.prepared_qubits = []",
        "",
        "        # Generate random bits and prepare corresponding qubits",
        "        for i in range(num_qubits):",
        "            # Generate random bit (0 or 1)",
        "            random_bit = random.randint(0, 1)",
        "",
        "            # Store the bit internally",
        "            self.sent_bits.append(random_bit)",
        "",
        "            # Prepare qubit using b92_prepare_qubit method",
        "            qubit = self.b92_prepare_qubit(random_bit)",
        "",
        "            # Store the prepared qubit",
        "            self.prepared_qubits.append(qubit)",
        "",
        "        # Display summary",
        "        print(f\"\\n{self.name} prepared {num_qubits} qubits successfully!\")",
        "        print(f\"Random bits (first 10): {self.sent_bits[:10]}\")",
        "        print(f\"Prepared qubits (first 10): {self.prepared_qubits[:10]}\")",
        "",
        "        # Return the prepared qubits",
        "        return self.prepared_qubits",
        "",
        "        Create a method that accepts two parameters: a quantum state string and an optional channel reference.",
        "        Call the measurement method with the quantum state to obtain an outcome and basis.",
        "        Append a tuple containing the outcome and basis to the received measurements list.",
        "        Return True to confirm successful processing.",
        "",
        "    def b92_process_received_qbit(self, qbit, from_channel=None):",
        "",
        "        Process a received qubit by measuring it using B92 protocol.",
        "",
        "        Args:",
        "            qbit (str): The quantum state received ('|0⟩' or '|+⟩')",
        "            from_channel: The channel from which the qubit was received (optional)",
        "",
        "        Returns:",
        "            bool: True to confirm successful processing",
        "",
        "        # Measure the qubit using b92_measure_qubit method",
        "        outcome, basis = self.b92_measure_qubit(qbit)",
        "",
        "        # Store both the measurement outcome and the chosen basis",
        "        self.received_measurements.append((outcome, basis))",
        "",
        "        # Return True to confirm processing",
        "        return True",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating the error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors detected.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, check if it's a valid index within the sifted key list",
        "        - If valid:",
        "      * Increment the comparison counter",
        "      * If the sifted key value at that position does not match the reference bit, increment the error counter",
        "        After iteration, calculate the error rate:",
        "        - If comparison count is greater than 0, divide error count by comparison count",
        "        - Otherwise, set error rate to 0.0",
        "        Print a completion message.",
        "        Print the number of errors found.",
        "        Print the total number of comparisons made.",
        "        Print the calculated error rate as a percentage with 2 decimal places.",
        "        Return the error rate as a floating-point value.",
        "",
        "    def b92_estimate_error_rate(self, sample_positions, reference_bits):",
        "",
        "        Estimate the error rate by comparing sample positions from sifted key with reference bits.",
        "",
        "        Args:",
        "            sample_positions (list): Indices of sifted key bits to check",
        "            reference_bits (list): Reference bit values to compare against",
        "",
        "        Returns:",
        "            float: Calculated error rate (0.0 to 1.0)",
        "",
        "        print(f\"\\n{self.name} is calculating B92 error rate...\")",
        "",
        "        # Initialize counters",
        "        comparison_count = 0",
        "        error_count = 0",
        "",
        "        # Iterate through sample positions and reference bits",
        "        for position, reference_bit in zip(sample_positions, reference_bits):",
        "            # Check if position is valid relative to sifted key",
        "            if position < len(self.sifted_key):",
        "                # Increase comparison count",
        "                comparison_count += 1",
        "",
        "                # Check for mismatch between sifted key and reference bit",
        "                if self.sifted_key[position] != reference_bit:",
        "                    # Increase error count",
        "                    error_count += 1",
        "",
        "        # Calculate error rate (default to 0.0 if no comparisons)",
        "        if comparison_count > 0:",
        "            error_rate = error_count / comparison_count",
        "        else:",
        "            error_rate = 0.0",
        "",
        "        # Display summary",
        "        print(f\"\\n{self.name} B92 error rate estimation complete!\")",
        "        print(f\"Errors found: {error_count}\")",
        "        print(f\"Total comparisons: {comparison_count}\")",
        "        print(f\"Calculated error rate: {error_rate:.2%}\")",
        "",
        "        # Return the computed error rate",
        "        return error_rate",
        "        \"\"\"",
        ""
      ],
      "output": "",
      "code_length": 14031,
      "line_count": 320
    },
    {
      "protocol": "B92",
      "timestamp": "2025-10-15T10:41:33.443873",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "import random",
        "",
        "class StudentB92Host:",
        "    # Student's B92 QKD implementation class with instance methods.",
        "    # All prompts are included above their respective implementations.",
        "    #",
        "    # B92 Protocol Summary:",
        "    # - Alice encodes: bit 0 -> |0⟩, bit 1 -> |+⟩ = (|0⟩ + |1⟩)/√2",
        "    # - Bob measures randomly in Z or X basis",
        "    # - Bob keeps only results where he measures |1⟩ (outcome = 1)",
        "    # - If Bob measures |1⟩ in Z basis -> Alice sent |+⟩ (bit 1)",
        "    # - If Bob measures |1⟩ in X basis -> Alice sent |0⟩ (bit 0)",
        "",
        "    def __init__(self, name):",
        "        \"\"\"",
        "        Initialize a StudentB92Host instance for the B92 protocol.",
        "",
        "        Args:",
        "            name (str): The name of the host (e.g., 'Alice' or 'Bob')",
        "        \"\"\"",
        "        # Store the host name for logging purposes",
        "        self.name = name",
        "",
        "        # Initialize empty lists for B92 protocol state tracking",
        "        self.sent_bits = []  # Bits that were sent",
        "        self.prepared_qubits = []  # Prepared quantum states",
        "        self.received_measurements = []  # Measurements received",
        "        self.sifted_key = []  # Final sifted key after reconciliation",
        "        self.random_bits = []  # Random bits generated",
        "        self.measurement_outcomes = []  # Measurement results obtained",
        "        self.received_bases = []  # Bases used for receiving qubits",
        "",
        "        # Print initialization message",
        "        print(f\"StudentB92Host '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts a single binary value (0 or 1) as input.",
        "        Validate that the input is either 0 or 1; if not, raise a ValueError with an appropriate message.",
        "        Map the binary value to a quantum state using the following encoding:",
        "        - If the value is 0, return the state string \"|0⟩\"",
        "        - If the value is 1, return the state string \"|+⟩\"",
        "        Return the prepared quantum state string.",
        "",
        "    def b92_prepare_qubit(self, bit):",
        "",
        "        Prepare a qubit based on a classical bit following the B92 protocol.",
        "",
        "        Args:",
        "            bit (int): Classical bit value (0 or 1)",
        "",
        "        Returns:",
        "            str: Prepared quantum state ('|0⟩' or '|+⟩')",
        "",
        "        Raises:",
        "            ValueError: If bit is not 0 or 1",
        "",
        "        # Validate input bit",
        "        if bit not in [0, 1]:",
        "            raise ValueError(f\"Invalid bit value: {bit}. Must be 0 or 1.\")",
        "",
        "        # Map bit to non-orthogonal quantum state (B92 encoding)",
        "        if bit == 0:",
        "            qubit = '|0⟩'  # Bit 0 maps to |0⟩ state",
        "        else:  # bit == 1",
        "            qubit = '|+⟩'  # Bit 1 maps to |+⟩ superposition state",
        "",
        "        # Return the prepared qubit",
        "        return qubit",
        "",
        "        Create a method that accepts a quantum state string as input.",
        "        Randomly select a measurement basis from two options: \"Z\" or \"X\".",
        "        Perform measurement following these rules:",
        "        - If the selected basis is \"Z\":",
        "      * If the state is '|0⟩', set outcome to 0 (deterministic)",
        "      * If the state is '|+⟩', set outcome to a random value (0 or 1 with equal probability)",
        "      * For any other state, set outcome to a random value (0 or 1)",
        "        - If the selected basis is \"X\":",
        "      * If the state is '|+⟩', set outcome to 0 (deterministic)",
        "      * If the state is '|0⟩', set outcome to a random value (0 or 1 with equal probability)",
        "      * For any other state, set outcome to a random value (0 or 1)",
        "        Return a tuple containing the measurement outcome and the selected basis.",
        "",
        "    def b92_measure_qubit(self, qubit):",
        "",
        "        Measure a qubit in a randomly chosen basis following B92 protocol.",
        "",
        "        Args:",
        "            qubit (str): Quantum state to measure ('|0⟩' or '|+⟩')",
        "",
        "        Returns:",
        "            tuple: (outcome, basis) - measurement outcome (0 or 1) and basis used (\"Z\" or \"X\")",
        "",
        "        # Randomly choose measurement basis",
        "        basis = random.choice([\"Z\", \"X\"])",
        "",
        "        # Perform measurement based on chosen basis",
        "        if basis == \"Z\":  # Measuring in Z (computational) basis",
        "            if qubit == '|0⟩':",
        "                outcome = 0  # |0⟩ in Z basis: deterministic outcome 0",
        "            elif qubit == '|+⟩':",
        "                outcome = random.randint(0, 1)  # |+⟩ in Z basis: 50% probability for 0 or 1",
        "            else:",
        "                # Handle other states if present",
        "                outcome = random.randint(0, 1)",
        "",
        "        else:  # basis == \"X\" - Measuring in X (Hadamard) basis",
        "            if qubit == '|+⟩':",
        "                outcome = 0  # |+⟩ in X basis: deterministic outcome 0 (+1 eigenstate)",
        "            elif qubit == '|0⟩':",
        "                outcome = random.randint(0, 1)  # |0⟩ in X basis: 50% probability for 0 or 1",
        "            else:",
        "                # Handle other states if present",
        "                outcome = random.randint(0, 1)",
        "",
        "        # Return both outcome and basis",
        "        return outcome, basis",
        "        Create a method that accepts two parameters: a list of transmitted bits and a list of measurement tuples (each containing an outcome and a basis).",
        "        Print a message indicating the host is performing sifting.",
        "        Initialize two empty lists: one for storing indices of conclusive results and one for storing the sifted key bits.",
        "        Iterate through the measurement tuples with enumeration to track positions:",
        "        - For each tuple where the outcome equals 1 (conclusive result):",
        "      * Append the current index to the indices list",
        "      * If the basis is \"Z\", append bit value 1 to the sifted key list",
        "      * If the basis is \"X\", append bit value 0 to the sifted key list",
        "        Store the sifted key list in the instance variable for future use.",
        "        Calculate the total number of measurements and the count of conclusive results.",
        "        Calculate the sifting efficiency as the ratio of conclusive results to total measurements (or 0 if total is 0).",
        "        Print a summary showing: total measurements, conclusive results count, sifting efficiency as a percentage with 2 decimals, and the first 10 bits of the sifted key.",
        "        Return a tuple containing the indices list and the sifted key list.",
        "",
        "    def b92_sifting(self, sent_bits, received_measurements):",
        "",
        "        Perform sifting stage of B92 protocol by keeping only conclusive measurements.",
        "",
        "        Args:",
        "            sent_bits (list): Bits that were sent by Alice",
        "            received_measurements (list): List of (outcome, basis) tuples from Bob's measurements",
        "",
        "        Returns:",
        "            tuple: (sifted_indices, sifted_key) - indices of conclusive results and corresponding bits",
        "",
        "        print(f\"\\n{self.name} is performing B92 sifting...\")",
        "",
        "        # Initialize collections for sifted data",
        "        sifted_indices = []",
        "        sifted_key = []",
        "",
        "        # Iterate through received measurements with their positions",
        "        for index, (outcome, basis) in enumerate(received_measurements):",
        "            # Keep only conclusive outcomes (result = 1)",
        "            if outcome == 1:",
        "                # Record the index of this conclusive measurement",
        "                sifted_indices.append(index)",
        "",
        "                # Determine the bit based on basis used",
        "                if basis == \"Z\":",
        "                    # In Z basis: outcome 1 conclusively indicates sender sent |+⟩ (bit 1)",
        "                    bit = 1",
        "                else:  # basis == \"X\"",
        "                    # In X basis: outcome 1 conclusively indicates sender sent |0⟩ (bit 0)",
        "                    bit = 0",
        "",
        "                # Add the determined bit to sifted key",
        "                sifted_key.append(bit)",
        "",
        "        # Store sifted key for future use",
        "        self.sifted_key = sifted_key",
        "",
        "        # Display sifting summary",
        "        total_measurements = len(received_measurements)",
        "        conclusive_count = len(sifted_key)",
        "        sifting_efficiency = conclusive_count / total_measurements if total_measurements > 0 else 0",
        "",
        "        print(f\"Total measurements: {total_measurements}\")",
        "        print(f\"Conclusive results: {conclusive_count}\")",
        "        print(f\"Sifting efficiency: {sifting_efficiency:.2%}\")",
        "        print(f\"Sifted key (first 10): {sifted_key[:10]}\")",
        "",
        "        # Return sifted indices and key",
        "        return sifted_indices, sifted_key",
        "",
        "        Create a method that accepts an integer parameter specifying how many qubits to generate.",
        "        Print a message indicating the host is preparing to send the specified number of qubits.",
        "        Clear and reinitialize two instance lists: one for transmitted bits and one for prepared qubits.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random binary value (0 or 1)",
        "        - Append this value to the transmitted bits list",
        "        - Call the preparation method with this binary value to get a quantum state",
        "        - Append the returned quantum state to the prepared qubits list",
        "        After processing all qubits, print a success message showing how many qubits were prepared.",
        "        Print the first 10 elements of the transmitted bits list with a label.",
        "        Print the first 10 elements of the prepared qubits list with a label.",
        "        Return the list of prepared quantum states.",
        "        \"\"\"",
        "    def b92_send_qubits(self, num_qubits):",
        "        \"\"\"",
        "        Generate random bits and prepare qubits for transmission using B92 protocol.",
        "",
        "        Args:",
        "            num_qubits (int): Number of qubits to prepare and send",
        "",
        "        Returns:",
        "            list: List of prepared quantum states",
        "        \"\"\"",
        "        print(f\"\\n{self.name} is preparing to send {num_qubits} qubits using B92 protocol...\")",
        "",
        "        # Initialize/reset internal storage",
        "        self.sent_bits = []",
        "        self.prepared_qubits = []",
        "",
        "        # Generate random bits and prepare corresponding qubits",
        "        for i in range(num_qubits):",
        "            # Generate random bit (0 or 1)",
        "            random_bit = random.randint(0, 1)",
        "",
        "            # Store the bit internally",
        "            self.sent_bits.append(random_bit)",
        "",
        "            # Prepare qubit using b92_prepare_qubit method",
        "            qubit = self.b92_prepare_qubit(random_bit)",
        "",
        "            # Store the prepared qubit",
        "            self.prepared_qubits.append(qubit)",
        "",
        "        # Display summary",
        "        print(f\"\\n{self.name} prepared {num_qubits} qubits successfully!\")",
        "        print(f\"Random bits (first 10): {self.sent_bits[:10]}\")",
        "        print(f\"Prepared qubits (first 10): {self.prepared_qubits[:10]}\")",
        "",
        "        # Return the prepared qubits",
        "        return self.prepared_qubits",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a quantum state string and an optional channel reference.",
        "        Call the measurement method with the quantum state to obtain an outcome and basis.",
        "        Append a tuple containing the outcome and basis to the received measurements list.",
        "        Return True to confirm successful processing.",
        "",
        "    def b92_process_received_qbit(self, qbit, from_channel=None):",
        "",
        "        Process a received qubit by measuring it using B92 protocol.",
        "",
        "        Args:",
        "            qbit (str): The quantum state received ('|0⟩' or '|+⟩')",
        "            from_channel: The channel from which the qubit was received (optional)",
        "",
        "        Returns:",
        "            bool: True to confirm successful processing",
        "",
        "        # Measure the qubit using b92_measure_qubit method",
        "        outcome, basis = self.b92_measure_qubit(qbit)",
        "",
        "        # Store both the measurement outcome and the chosen basis",
        "        self.received_measurements.append((outcome, basis))",
        "",
        "        # Return True to confirm processing",
        "        return True",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating the error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors detected.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, check if it's a valid index within the sifted key list",
        "        - If valid:",
        "      * Increment the comparison counter",
        "      * If the sifted key value at that position does not match the reference bit, increment the error counter",
        "        After iteration, calculate the error rate:",
        "        - If comparison count is greater than 0, divide error count by comparison count",
        "        - Otherwise, set error rate to 0.0",
        "        Print a completion message.",
        "        Print the number of errors found.",
        "        Print the total number of comparisons made.",
        "        Print the calculated error rate as a percentage with 2 decimal places.",
        "        Return the error rate as a floating-point value.",
        "",
        "    def b92_estimate_error_rate(self, sample_positions, reference_bits):",
        "",
        "        Estimate the error rate by comparing sample positions from sifted key with reference bits.",
        "",
        "        Args:",
        "            sample_positions (list): Indices of sifted key bits to check",
        "            reference_bits (list): Reference bit values to compare against",
        "",
        "        Returns:",
        "            float: Calculated error rate (0.0 to 1.0)",
        "",
        "        print(f\"\\n{self.name} is calculating B92 error rate...\")",
        "",
        "        # Initialize counters",
        "        comparison_count = 0",
        "        error_count = 0",
        "",
        "        # Iterate through sample positions and reference bits",
        "        for position, reference_bit in zip(sample_positions, reference_bits):",
        "            # Check if position is valid relative to sifted key",
        "            if position < len(self.sifted_key):",
        "                # Increase comparison count",
        "                comparison_count += 1",
        "",
        "                # Check for mismatch between sifted key and reference bit",
        "                if self.sifted_key[position] != reference_bit:",
        "                    # Increase error count",
        "                    error_count += 1",
        "",
        "        # Calculate error rate (default to 0.0 if no comparisons)",
        "        if comparison_count > 0:",
        "            error_rate = error_count / comparison_count",
        "        else:",
        "            error_rate = 0.0",
        "",
        "        # Display summary",
        "        print(f\"\\n{self.name} B92 error rate estimation complete!\")",
        "        print(f\"Errors found: {error_count}\")",
        "        print(f\"Total comparisons: {comparison_count}\")",
        "        print(f\"Calculated error rate: {error_rate:.2%}\")",
        "",
        "        # Return the computed error rate",
        "        return error_rate",
        "        \"\"\"",
        ""
      ],
      "output": "",
      "code_length": 14076,
      "line_count": 321
    },
    {
      "protocol": "B92",
      "timestamp": "2025-10-15T10:42:37.749057",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "import random",
        "",
        "class StudentB92Host:",
        "    # Student's B92 QKD implementation class with instance methods.",
        "    # All prompts are included above their respective implementations.",
        "    #",
        "    # B92 Protocol Summary:",
        "    # - Alice encodes: bit 0 -> |0⟩, bit 1 -> |+⟩ = (|0⟩ + |1⟩)/√2",
        "    # - Bob measures randomly in Z or X basis",
        "    # - Bob keeps only results where he measures |1⟩ (outcome = 1)",
        "    # - If Bob measures |1⟩ in Z basis -> Alice sent |+⟩ (bit 1)",
        "    # - If Bob measures |1⟩ in X basis -> Alice sent |0⟩ (bit 0)",
        "",
        "    def __init__(self, name):",
        "        \"\"\"",
        "        Initialize a StudentB92Host instance for the B92 protocol.",
        "",
        "        Args:",
        "            name (str): The name of the host (e.g., 'Alice' or 'Bob')",
        "        \"\"\"",
        "        # Store the host name for logging purposes",
        "        self.name = name",
        "",
        "        # Initialize empty lists for B92 protocol state tracking",
        "        self.sent_bits = []  # Bits that were sent",
        "        self.prepared_qubits = []  # Prepared quantum states",
        "        self.received_measurements = []  # Measurements received",
        "        self.sifted_key = []  # Final sifted key after reconciliation",
        "        self.random_bits = []  # Random bits generated",
        "        self.measurement_outcomes = []  # Measurement results obtained",
        "        self.received_bases = []  # Bases used for receiving qubits",
        "",
        "        # Print initialization message",
        "        print(f\"StudentB92Host '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts a single binary value (0 or 1) as input.",
        "        Validate that the input is either 0 or 1; if not, raise a ValueError with an appropriate message.",
        "        Map the binary value to a quantum state using the following encoding:",
        "        - If the value is 0, return the state string \"|0⟩\"",
        "        - If the value is 1, return the state string \"|+⟩\"",
        "        Return the prepared quantum state string.",
        "",
        "    def b92_prepare_qubit(self, bit):",
        "",
        "        Prepare a qubit based on a classical bit following the B92 protocol.",
        "",
        "        Args:",
        "            bit (int): Classical bit value (0 or 1)",
        "",
        "        Returns:",
        "            str: Prepared quantum state ('|0⟩' or '|+⟩')",
        "",
        "        Raises:",
        "            ValueError: If bit is not 0 or 1",
        "",
        "        # Validate input bit",
        "        if bit not in [0, 1]:",
        "            raise ValueError(f\"Invalid bit value: {bit}. Must be 0 or 1.\")",
        "",
        "        # Map bit to non-orthogonal quantum state (B92 encoding)",
        "        if bit == 0:",
        "            qubit = '|0⟩'  # Bit 0 maps to |0⟩ state",
        "        else:  # bit == 1",
        "            qubit = '|+⟩'  # Bit 1 maps to |+⟩ superposition state",
        "",
        "        # Return the prepared qubit",
        "        return qubit",
        "",
        "        Create a method that accepts a quantum state string as input.",
        "        Randomly select a measurement basis from two options: \"Z\" or \"X\".",
        "        Perform measurement following these rules:",
        "        - If the selected basis is \"Z\":",
        "      * If the state is '|0⟩', set outcome to 0 (deterministic)",
        "      * If the state is '|+⟩', set outcome to a random value (0 or 1 with equal probability)",
        "      * For any other state, set outcome to a random value (0 or 1)",
        "        - If the selected basis is \"X\":",
        "      * If the state is '|+⟩', set outcome to 0 (deterministic)",
        "      * If the state is '|0⟩', set outcome to a random value (0 or 1 with equal probability)",
        "      * For any other state, set outcome to a random value (0 or 1)",
        "        Return a tuple containing the measurement outcome and the selected basis.",
        "",
        "    def b92_measure_qubit(self, qubit):",
        "",
        "        Measure a qubit in a randomly chosen basis following B92 protocol.",
        "",
        "        Args:",
        "            qubit (str): Quantum state to measure ('|0⟩' or '|+⟩')",
        "",
        "        Returns:",
        "            tuple: (outcome, basis) - measurement outcome (0 or 1) and basis used (\"Z\" or \"X\")",
        "",
        "        # Randomly choose measurement basis",
        "        basis = random.choice([\"Z\", \"X\"])",
        "",
        "        # Perform measurement based on chosen basis",
        "        if basis == \"Z\":  # Measuring in Z (computational) basis",
        "            if qubit == '|0⟩':",
        "                outcome = 0  # |0⟩ in Z basis: deterministic outcome 0",
        "            elif qubit == '|+⟩':",
        "                outcome = random.randint(0, 1)  # |+⟩ in Z basis: 50% probability for 0 or 1",
        "            else:",
        "                # Handle other states if present",
        "                outcome = random.randint(0, 1)",
        "",
        "        else:  # basis == \"X\" - Measuring in X (Hadamard) basis",
        "            if qubit == '|+⟩':",
        "                outcome = 0  # |+⟩ in X basis: deterministic outcome 0 (+1 eigenstate)",
        "            elif qubit == '|0⟩':",
        "                outcome = random.randint(0, 1)  # |0⟩ in X basis: 50% probability for 0 or 1",
        "            else:",
        "                # Handle other states if present",
        "                outcome = random.randint(0, 1)",
        "",
        "        # Return both outcome and basis",
        "        return outcome, basis",
        "        Create a method that accepts two parameters: a list of transmitted bits and a list of measurement tuples (each containing an outcome and a basis).",
        "        Print a message indicating the host is performing sifting.",
        "        Initialize two empty lists: one for storing indices of conclusive results and one for storing the sifted key bits.",
        "        Iterate through the measurement tuples with enumeration to track positions:",
        "        - For each tuple where the outcome equals 1 (conclusive result):",
        "      * Append the current index to the indices list",
        "      * If the basis is \"Z\", append bit value 1 to the sifted key list",
        "      * If the basis is \"X\", append bit value 0 to the sifted key list",
        "        Store the sifted key list in the instance variable for future use.",
        "        Calculate the total number of measurements and the count of conclusive results.",
        "        Calculate the sifting efficiency as the ratio of conclusive results to total measurements (or 0 if total is 0).",
        "        Print a summary showing: total measurements, conclusive results count, sifting efficiency as a percentage with 2 decimals, and the first 10 bits of the sifted key.",
        "        Return a tuple containing the indices list and the sifted key list.",
        "",
        "    def b92_sifting(self, sent_bits, received_measurements):",
        "",
        "        Perform sifting stage of B92 protocol by keeping only conclusive measurements.",
        "",
        "        Args:",
        "            sent_bits (list): Bits that were sent by Alice",
        "            received_measurements (list): List of (outcome, basis) tuples from Bob's measurements",
        "",
        "        Returns:",
        "            tuple: (sifted_indices, sifted_key) - indices of conclusive results and corresponding bits",
        "",
        "        print(f\"\\n{self.name} is performing B92 sifting...\")",
        "",
        "        # Initialize collections for sifted data",
        "        sifted_indices = []",
        "        sifted_key = []",
        "",
        "        # Iterate through received measurements with their positions",
        "        for index, (outcome, basis) in enumerate(received_measurements):",
        "            # Keep only conclusive outcomes (result = 1)",
        "            if outcome == 1:",
        "                # Record the index of this conclusive measurement",
        "                sifted_indices.append(index)",
        "",
        "                # Determine the bit based on basis used",
        "                if basis == \"Z\":",
        "                    # In Z basis: outcome 1 conclusively indicates sender sent |+⟩ (bit 1)",
        "                    bit = 1",
        "                else:  # basis == \"X\"",
        "                    # In X basis: outcome 1 conclusively indicates sender sent |0⟩ (bit 0)",
        "                    bit = 0",
        "",
        "                # Add the determined bit to sifted key",
        "                sifted_key.append(bit)",
        "",
        "        # Store sifted key for future use",
        "        self.sifted_key = sifted_key",
        "",
        "        # Display sifting summary",
        "        total_measurements = len(received_measurements)",
        "        conclusive_count = len(sifted_key)",
        "        sifting_efficiency = conclusive_count / total_measurements if total_measurements > 0 else 0",
        "",
        "        print(f\"Total measurements: {total_measurements}\")",
        "        print(f\"Conclusive results: {conclusive_count}\")",
        "        print(f\"Sifting efficiency: {sifting_efficiency:.2%}\")",
        "        print(f\"Sifted key (first 10): {sifted_key[:10]}\")",
        "",
        "        # Return sifted indices and key",
        "        return sifted_indices, sifted_key",
        "",
        "        Create a method that accepts an integer parameter specifying how many qubits to generate.",
        "        Print a message indicating the host is preparing to send the specified number of qubits.",
        "        Clear and reinitialize two instance lists: one for transmitted bits and one for prepared qubits.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random binary value (0 or 1)",
        "        - Append this value to the transmitted bits list",
        "        - Call the preparation method with this binary value to get a quantum state",
        "        - Append the returned quantum state to the prepared qubits list",
        "        After processing all qubits, print a success message showing how many qubits were prepared.",
        "        Print the first 10 elements of the transmitted bits list with a label.",
        "        Print the first 10 elements of the prepared qubits list with a label.",
        "        Return the list of prepared quantum states.",
        "        \"\"\"",
        "    def b92_send_qubits(self, num_qubits):",
        "        \"\"\"",
        "        Generate random bits and prepare qubits for transmission using B92 protocol.",
        "",
        "        Args:",
        "            num_qubits (int): Number of qubits to prepare and send",
        "",
        "        Returns:",
        "            list: List of prepared quantum states",
        "        \"\"\"",
        "        print(f\"\\n{self.name} is preparing to send {num_qubits} qubits using B92 protocol...\")",
        "",
        "        # Initialize/reset internal storage",
        "        self.sent_bits = []",
        "        self.prepared_qubits = []",
        "",
        "        # Generate random bits and prepare corresponding qubits",
        "        for i in range(num_qubits):",
        "            # Generate random bit (0 or 1)",
        "            random_bit = random.randint(0, 1)",
        "",
        "            # Store the bit internally",
        "            self.sent_bits.append(random_bit)",
        "",
        "            # Prepare qubit using b92_prepare_qubit method",
        "            qubit = self.b92_prepare_qubit(random_bit)",
        "",
        "            # Store the prepared qubit",
        "            self.prepared_qubits.append(qubit)",
        "",
        "        # Display summary",
        "        print(f\"\\n{self.name} prepared {num_qubits} qubits successfully!\")",
        "        print(f\"Random bits (first 10): {self.sent_bits[:10]}\")",
        "        print(f\"Prepared qubits (first 10): {self.prepared_qubits[:10]}\")",
        "",
        "        # Return the prepared qubits",
        "        return self.prepared_qubits",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a quantum state string and an optional channel reference.",
        "        Call the measurement method with the quantum state to obtain an outcome and basis.",
        "        Append a tuple containing the outcome and basis to the received measurements list.",
        "        Return True to confirm successful processing.",
        "        \"\"\"",
        "    def b92_process_received_qbit(self, qbit, from_channel=None):",
        "        \"\"\"",
        "        Process a received qubit by measuring it using B92 protocol.",
        "",
        "        Args:",
        "            qbit (str): The quantum state received ('|0⟩' or '|+⟩')",
        "            from_channel: The channel from which the qubit was received (optional)",
        "",
        "        Returns:",
        "            bool: True to confirm successful processing",
        "            \"\"\"",
        "",
        "        # Measure the qubit using b92_measure_qubit method",
        "        outcome, basis = self.b92_measure_qubit(qbit)",
        "",
        "        # Store both the measurement outcome and the chosen basis",
        "        self.received_measurements.append((outcome, basis))",
        "",
        "        # Return True to confirm processing",
        "        return True",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating the error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors detected.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, check if it's a valid index within the sifted key list",
        "        - If valid:",
        "      * Increment the comparison counter",
        "      * If the sifted key value at that position does not match the reference bit, increment the error counter",
        "        After iteration, calculate the error rate:",
        "        - If comparison count is greater than 0, divide error count by comparison count",
        "        - Otherwise, set error rate to 0.0",
        "        Print a completion message.",
        "        Print the number of errors found.",
        "        Print the total number of comparisons made.",
        "        Print the calculated error rate as a percentage with 2 decimal places.",
        "        Return the error rate as a floating-point value.",
        "",
        "    def b92_estimate_error_rate(self, sample_positions, reference_bits):",
        "",
        "        Estimate the error rate by comparing sample positions from sifted key with reference bits.",
        "",
        "        Args:",
        "            sample_positions (list): Indices of sifted key bits to check",
        "            reference_bits (list): Reference bit values to compare against",
        "",
        "        Returns:",
        "            float: Calculated error rate (0.0 to 1.0)",
        "",
        "        print(f\"\\n{self.name} is calculating B92 error rate...\")",
        "",
        "        # Initialize counters",
        "        comparison_count = 0",
        "        error_count = 0",
        "",
        "        # Iterate through sample positions and reference bits",
        "        for position, reference_bit in zip(sample_positions, reference_bits):",
        "            # Check if position is valid relative to sifted key",
        "            if position < len(self.sifted_key):",
        "                # Increase comparison count",
        "                comparison_count += 1",
        "",
        "                # Check for mismatch between sifted key and reference bit",
        "                if self.sifted_key[position] != reference_bit:",
        "                    # Increase error count",
        "                    error_count += 1",
        "",
        "        # Calculate error rate (default to 0.0 if no comparisons)",
        "        if comparison_count > 0:",
        "            error_rate = error_count / comparison_count",
        "        else:",
        "            error_rate = 0.0",
        "",
        "        # Display summary",
        "        print(f\"\\n{self.name} B92 error rate estimation complete!\")",
        "        print(f\"Errors found: {error_count}\")",
        "        print(f\"Total comparisons: {comparison_count}\")",
        "        print(f\"Calculated error rate: {error_rate:.2%}\")",
        "",
        "        # Return the computed error rate",
        "        return error_rate",
        "        \"\"\"",
        ""
      ],
      "output": "",
      "code_length": 14127,
      "line_count": 324
    },
    {
      "protocol": "B92",
      "timestamp": "2025-10-15T10:44:52.360014",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "import random",
        "",
        "class StudentB92Host:",
        "    # Student's B92 QKD implementation class with instance methods.",
        "    # All prompts are included above their respective implementations.",
        "    #",
        "    # B92 Protocol Summary:",
        "    # - Alice encodes: bit 0 -> |0⟩, bit 1 -> |+⟩ = (|0⟩ + |1⟩)/√2",
        "    # - Bob measures randomly in Z or X basis",
        "    # - Bob keeps only results where he measures |1⟩ (outcome = 1)",
        "    # - If Bob measures |1⟩ in Z basis -> Alice sent |+⟩ (bit 1)",
        "    # - If Bob measures |1⟩ in X basis -> Alice sent |0⟩ (bit 0)",
        "",
        "    def __init__(self, name):",
        "        \"\"\"",
        "        Initialize a StudentB92Host instance for the B92 protocol.",
        "",
        "        Args:",
        "            name (str): The name of the host (e.g., 'Alice' or 'Bob')",
        "        \"\"\"",
        "        # Store the host name for logging purposes",
        "        self.name = name",
        "",
        "        # Initialize empty lists for B92 protocol state tracking",
        "        self.sent_bits = []  # Bits that were sent",
        "        self.prepared_qubits = []  # Prepared quantum states",
        "        self.received_measurements = []  # Measurements received",
        "        self.sifted_key = []  # Final sifted key after reconciliation",
        "        self.random_bits = []  # Random bits generated",
        "        self.measurement_outcomes = []  # Measurement results obtained",
        "        self.received_bases = []  # Bases used for receiving qubits",
        "",
        "        # Print initialization message",
        "        print(f\"StudentB92Host '{self.name}' initialized successfully!\")",
        "",
        "        \"\"\"",
        "        Create a method that accepts a single binary value (0 or 1) as input.",
        "        Validate that the input is either 0 or 1; if not, raise a ValueError with an appropriate message.",
        "        Map the binary value to a quantum state using the following encoding:",
        "        - If the value is 0, return the state string \"|0⟩\"",
        "        - If the value is 1, return the state string \"|+⟩\"",
        "        Return the prepared quantum state string.",
        "        \"\"\"",
        "    def b92_prepare_qubit(self, bit):",
        "        \"\"\"",
        "        Prepare a qubit based on a classical bit following the B92 protocol.",
        "",
        "        Args:",
        "            bit (int): Classical bit value (0 or 1)",
        "",
        "        Returns:",
        "            str: Prepared quantum state ('|0⟩' or '|+⟩')",
        "",
        "        Raises:",
        "            ValueError: If bit is not 0 or 1",
        "        \"\"\"",
        "        # Validate input bit",
        "        if bit not in [0, 1]:",
        "            raise ValueError(f\"Invalid bit value: {bit}. Must be 0 or 1.\")",
        "",
        "        # Map bit to non-orthogonal quantum state (B92 encoding)",
        "        if bit == 0:",
        "            qubit = '|0⟩'  # Bit 0 maps to |0⟩ state",
        "        else:  # bit == 1",
        "            qubit = '|+⟩'  # Bit 1 maps to |+⟩ superposition state",
        "",
        "        # Return the prepared qubit",
        "        return qubit",
        "",
        "        \"\"\"",
        "        Create a method that accepts a quantum state string as input.",
        "        Randomly select a measurement basis from two options: \"Z\" or \"X\".",
        "        Perform measurement following these rules:",
        "        - If the selected basis is \"Z\":",
        "      * If the state is '|0⟩', set outcome to 0 (deterministic)",
        "      * If the state is '|+⟩', set outcome to a random value (0 or 1 with equal probability)",
        "      * For any other state, set outcome to a random value (0 or 1)",
        "        - If the selected basis is \"X\":",
        "      * If the state is '|+⟩', set outcome to 0 (deterministic)",
        "      * If the state is '|0⟩', set outcome to a random value (0 or 1 with equal probability)",
        "      * For any other state, set outcome to a random value (0 or 1)",
        "        Return a tuple containing the measurement outcome and the selected basis.",
        "        \"\"\"",
        "    def b92_measure_qubit(self, qubit):",
        "        \"\"\"",
        "        Measure a qubit in a randomly chosen basis following B92 protocol.",
        "",
        "        Args:",
        "            qubit (str): Quantum state to measure ('|0⟩' or '|+⟩')",
        "",
        "        Returns:",
        "            tuple: (outcome, basis) - measurement outcome (0 or 1) and basis used (\"Z\" or \"X\")",
        "        \"\"\"",
        "        # Randomly choose measurement basis",
        "        basis = random.choice([\"Z\", \"X\"])",
        "",
        "        # Perform measurement based on chosen basis",
        "        if basis == \"Z\":  # Measuring in Z (computational) basis",
        "            if qubit == '|0⟩':",
        "                outcome = 0  # |0⟩ in Z basis: deterministic outcome 0",
        "            elif qubit == '|+⟩':",
        "                outcome = random.randint(0, 1)  # |+⟩ in Z basis: 50% probability for 0 or 1",
        "            else:",
        "                # Handle other states if present",
        "                outcome = random.randint(0, 1)",
        "",
        "        else:  # basis == \"X\" - Measuring in X (Hadamard) basis",
        "            if qubit == '|+⟩':",
        "                outcome = 0  # |+⟩ in X basis: deterministic outcome 0 (+1 eigenstate)",
        "            elif qubit == '|0⟩':",
        "                outcome = random.randint(0, 1)  # |0⟩ in X basis: 50% probability for 0 or 1",
        "            else:",
        "                # Handle other states if present",
        "                outcome = random.randint(0, 1)",
        "",
        "        # Return both outcome and basis",
        "        return outcome, basis",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a list of transmitted bits and a list of measurement tuples (each containing an outcome and a basis).",
        "        Print a message indicating the host is performing sifting.",
        "        Initialize two empty lists: one for storing indices of conclusive results and one for storing the sifted key bits.",
        "        Iterate through the measurement tuples with enumeration to track positions:",
        "        - For each tuple where the outcome equals 1 (conclusive result):",
        "      * Append the current index to the indices list",
        "      * If the basis is \"Z\", append bit value 1 to the sifted key list",
        "      * If the basis is \"X\", append bit value 0 to the sifted key list",
        "        Store the sifted key list in the instance variable for future use.",
        "        Calculate the total number of measurements and the count of conclusive results.",
        "        Calculate the sifting efficiency as the ratio of conclusive results to total measurements (or 0 if total is 0).",
        "        Print a summary showing: total measurements, conclusive results count, sifting efficiency as a percentage with 2 decimals, and the first 10 bits of the sifted key.",
        "        Return a tuple containing the indices list and the sifted key list.",
        "        \"\"\"",
        "    def b92_sifting(self, sent_bits, received_measurements):",
        "        \"\"\"",
        "        Perform sifting stage of B92 protocol by keeping only conclusive measurements.",
        "",
        "        Args:",
        "            sent_bits (list): Bits that were sent by Alice",
        "            received_measurements (list): List of (outcome, basis) tuples from Bob's measurements",
        "",
        "        Returns:",
        "            tuple: (sifted_indices, sifted_key) - indices of conclusive results and corresponding bits",
        "        \"\"\"",
        "        print(f\"\\n{self.name} is performing B92 sifting...\")",
        "",
        "        # Initialize collections for sifted data",
        "        sifted_indices = []",
        "        sifted_key = []",
        "",
        "        # Iterate through received measurements with their positions",
        "        for index, (outcome, basis) in enumerate(received_measurements):",
        "            # Keep only conclusive outcomes (result = 1)",
        "            if outcome == 1:",
        "                # Record the index of this conclusive measurement",
        "                sifted_indices.append(index)",
        "",
        "                # Determine the bit based on basis used",
        "                if basis == \"Z\":",
        "                    # In Z basis: outcome 1 conclusively indicates sender sent |+⟩ (bit 1)",
        "                    bit = 1",
        "                else:  # basis == \"X\"",
        "                    # In X basis: outcome 1 conclusively indicates sender sent |0⟩ (bit 0)",
        "                    bit = 0",
        "",
        "                # Add the determined bit to sifted key",
        "                sifted_key.append(bit)",
        "",
        "        # Store sifted key for future use",
        "        self.sifted_key = sifted_key",
        "",
        "        # Display sifting summary",
        "        total_measurements = len(received_measurements)",
        "        conclusive_count = len(sifted_key)",
        "        sifting_efficiency = conclusive_count / total_measurements if total_measurements > 0 else 0",
        "",
        "        print(f\"Total measurements: {total_measurements}\")",
        "        print(f\"Conclusive results: {conclusive_count}\")",
        "        print(f\"Sifting efficiency: {sifting_efficiency:.2%}\")",
        "        print(f\"Sifted key (first 10): {sifted_key[:10]}\")",
        "",
        "        # Return sifted indices and key",
        "        return sifted_indices, sifted_key",
        "",
        "        \"\"\"",
        "        Create a method that accepts an integer parameter specifying how many qubits to generate.",
        "        Print a message indicating the host is preparing to send the specified number of qubits.",
        "        Clear and reinitialize two instance lists: one for transmitted bits and one for prepared qubits.",
        "        For each qubit in the specified quantity:",
        "        - Generate a random binary value (0 or 1)",
        "        - Append this value to the transmitted bits list",
        "        - Call the preparation method with this binary value to get a quantum state",
        "        - Append the returned quantum state to the prepared qubits list",
        "        After processing all qubits, print a success message showing how many qubits were prepared.",
        "        Print the first 10 elements of the transmitted bits list with a label.",
        "        Print the first 10 elements of the prepared qubits list with a label.",
        "        Return the list of prepared quantum states.",
        "        \"\"\"",
        "    def b92_send_qubits(self, num_qubits):",
        "        \"\"\"",
        "        Generate random bits and prepare qubits for transmission using B92 protocol.",
        "",
        "        Args:",
        "            num_qubits (int): Number of qubits to prepare and send",
        "",
        "        Returns:",
        "            list: List of prepared quantum states",
        "        \"\"\"",
        "        print(f\"\\n{self.name} is preparing to send {num_qubits} qubits using B92 protocol...\")",
        "",
        "        # Initialize/reset internal storage",
        "        self.sent_bits = []",
        "        self.prepared_qubits = []",
        "",
        "        # Generate random bits and prepare corresponding qubits",
        "        for i in range(num_qubits):",
        "            # Generate random bit (0 or 1)",
        "            random_bit = random.randint(0, 1)",
        "",
        "            # Store the bit internally",
        "            self.sent_bits.append(random_bit)",
        "",
        "            # Prepare qubit using b92_prepare_qubit method",
        "            qubit = self.b92_prepare_qubit(random_bit)",
        "",
        "            # Store the prepared qubit",
        "            self.prepared_qubits.append(qubit)",
        "",
        "        # Display summary",
        "        print(f\"\\n{self.name} prepared {num_qubits} qubits successfully!\")",
        "        print(f\"Random bits (first 10): {self.sent_bits[:10]}\")",
        "        print(f\"Prepared qubits (first 10): {self.prepared_qubits[:10]}\")",
        "",
        "        # Return the prepared qubits",
        "        return self.prepared_qubits",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a quantum state string and an optional channel reference.",
        "        Call the measurement method with the quantum state to obtain an outcome and basis.",
        "        Append a tuple containing the outcome and basis to the received measurements list.",
        "        Return True to confirm successful processing.",
        "        \"\"\"",
        "    def b92_process_received_qbit(self, qbit, from_channel=None):",
        "        \"\"\"",
        "        Process a received qubit by measuring it using B92 protocol.",
        "",
        "        Args:",
        "            qbit (str): The quantum state received ('|0⟩' or '|+⟩')",
        "            from_channel: The channel from which the qubit was received (optional)",
        "",
        "        Returns:",
        "            bool: True to confirm successful processing",
        "            \"\"\"",
        "",
        "        # Measure the qubit using b92_measure_qubit method",
        "        outcome, basis = self.b92_measure_qubit(qbit)",
        "",
        "        # Store both the measurement outcome and the chosen basis",
        "        self.received_measurements.append((outcome, basis))",
        "",
        "        # Return True to confirm processing",
        "        return True",
        "",
        "        \"\"\"",
        "        Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "        Print a message indicating the host is calculating the error rate.",
        "        Initialize two counters to zero: one for total comparisons and one for errors detected.",
        "        Iterate through the sample positions and reference bits simultaneously:",
        "        - For each position, check if it's a valid index within the sifted key list",
        "        - If valid:",
        "      * Increment the comparison counter",
        "      * If the sifted key value at that position does not match the reference bit, increment the error counter",
        "        After iteration, calculate the error rate:",
        "        - If comparison count is greater than 0, divide error count by comparison count",
        "        - Otherwise, set error rate to 0.0",
        "        Print a completion message.",
        "        Print the number of errors found.",
        "        Print the total number of comparisons made.",
        "        Print the calculated error rate as a percentage with 2 decimal places.",
        "        Return the error rate as a floating-point value.",
        "        \"\"\"",
        "    def b92_estimate_error_rate(self, sample_positions, reference_bits):",
        "        \"\"\"",
        "        Estimate the error rate by comparing sample positions from sifted key with reference bits.",
        "",
        "        Args:",
        "            sample_positions (list): Indices of sifted key bits to check",
        "            reference_bits (list): Reference bit values to compare against",
        "",
        "        Returns:",
        "            float: Calculated error rate (0.0 to 1.0)",
        "        \"\"\"",
        "        print(f\"\\n{self.name} is calculating B92 error rate...\")",
        "",
        "        # Initialize counters",
        "        comparison_count = 0",
        "        error_count = 0",
        "",
        "        # Iterate through sample positions and reference bits",
        "        for position, reference_bit in zip(sample_positions, reference_bits):",
        "            # Check if position is valid relative to sifted key",
        "            if position < len(self.sifted_key):",
        "                # Increase comparison count",
        "                comparison_count += 1",
        "",
        "                # Check for mismatch between sifted key and reference bit",
        "                if self.sifted_key[position] != reference_bit:",
        "                    # Increase error count",
        "                    error_count += 1",
        "",
        "        # Calculate error rate (default to 0.0 if no comparisons)",
        "        if comparison_count > 0:",
        "            error_rate = error_count / comparison_count",
        "        else:",
        "            error_rate = 0.0",
        "",
        "        # Display summary",
        "        print(f\"\\n{self.name} B92 error rate estimation complete!\")",
        "        print(f\"Errors found: {error_count}\")",
        "        print(f\"Total comparisons: {comparison_count}\")",
        "        print(f\"Calculated error rate: {error_rate:.2%}\")",
        "",
        "        # Return the computed error rate",
        "        return error_rate",
        ""
      ],
      "output": "",
      "code_length": 14284,
      "line_count": 327
    }
  ],
  "firebase_enabled": true,
  "last_updated": "2025-10-15T10:44:52.360039"
}