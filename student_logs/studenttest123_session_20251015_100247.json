{
  "student_id": "studenttest123",
  "session_id": "gpPnoaS3OftKCeKAXtKb",
  "session_start": "2025-10-15T10:02:47.461739",
  "activities": [
    {
      "protocol": "BB84",
      "timestamp": "2025-10-15T10:03:01.512982",
      "code": [
        "# coding: utf-8",
        "# coding: utf-8",
        "import random",
        "",
        "class StudentQuantumHost:",
        "",
        "    def __init__(self, name):",
        "        self.name = name",
        "        self.random_bits = []",
        "        self.measurement_bases = []",
        "        self.quantum_states = []",
        "        self.received_bases = []",
        "        self.measurement_outcomes = []",
        "        print(f\"StudentQuantumHost '{self.name}' initialized successfully!\")",
        "",
        "    \"\"\"",
        "    Create a method that accepts an integer parameter specifying the quantity of qubits to prepare.",
        "    Print a message indicating the host is preparing this quantity of qubits.",
        "    Clear and reinitialize three instance lists: one for random bits, one for bases, and one for quantum states.",
        "    For each qubit in the specified quantity:",
        "    - Generate a random bit (0 or 1)",
        "    - Generate a random basis (0 or 1)",
        "    - If basis is 0: encode bit 0 as \"|0⟩\" and bit 1 as \"|1⟩\"",
        "    - If basis is 1: encode bit 0 as \"|+⟩\" and bit 1 as \"|-⟩\"",
        "    - Append the random bit to the first list, the basis to the second list, and the encoded state to the third list",
        "    After processing all qubits, print a message showing how many qubits were prepared.",
        "    Return the list of encoded quantum states.",
        "    Create a method that accepts two parameters: a quantum state string and a channel reference.",
        "    Generate a random measurement basis (0 or 1) and append it to the received bases list.",
        "    Perform measurement based on the following rules:",
        "    - If measurement basis is 0 (rectilinear):",
        "      * State \"|0⟩\" yields outcome 0",
        "      * State \"|1⟩\" yields outcome 1",
        "      * States \"|+⟩\" or \"|-⟩\" yield random outcome (0 or 1)",
        "    - If measurement basis is 1 (diagonal):",
        "      * State \"|+⟩\" yields outcome 0",
        "      * State \"|-⟩\" yields outcome 1",
        "      * States \"|0⟩\" or \"|1⟩\" yield random outcome (0 or 1)",
        "    - For any other state, yield random outcome (0 or 1)",
        "    Append the measurement outcome to the measurement outcomes list.",
        "    Return True to indicate successful processing.",
        "    Create a method that accepts two parameters: both are lists of basis values representing sender and receiver bases.",
        "    Print a message indicating the host is comparing basis choices.",
        "    Create two empty lists: one for matching indices and one for corresponding bit values.",
        "    Iterate through both basis lists simultaneously with enumeration:",
        "    - For each index where both basis values are equal, append the index to the matching indices list",
        "    - If the index is valid for the measurement outcomes list, append the corresponding measurement outcome to the bits list",
        "    - Otherwise, if the index is valid for the random bits list, append the corresponding random bit to the bits list",
        "    Calculate total comparisons as the minimum length of the two basis lists.",
        "    Calculate the match proportion (matching count divided by total, or 0 if total is 0).",
        "    Print a message showing: \"Matches found: X / Y (Z%)\" where X is matches, Y is total, and Z is percentage with 1 decimal place.",
        "    Return both the matching indices list and the corresponding bits list.",
        "    Create a method that accepts two parameters: a list of sample position indices and a list of reference bit values.",
        "    Print a message indicating the host is calculating error rate.",
        "    Initialize two counters to zero: one for total comparisons and one for errors.",
        "    Iterate through the sample positions and reference bits simultaneously:",
        "    - For each position, if it's a valid index in the measurement outcomes list:",
        "      * Increment the comparison counter",
        "      * If the measurement outcome at that position doesn't match the reference bit, increment the error counter",
        "    - Otherwise, if the position is valid in the random bits list:",
        "      * Increment the comparison counter",
        "      * If the random bit at that position doesn't match the reference bit, increment the error counter",
        "    Calculate the error rate as errors divided by comparisons (or 0.0 if comparisons is 0).",
        "    Print a message showing: \"Error rate: X% (Y/Z)\" where X is the rate as percentage with 2 decimals, Y is error count, Z is comparison count.",
        "    Return the calculated error rate.",
        "    \"\"\"",
        "",
        "    #def bb84_estimate_error_rate(self, sample_positions, reference_bits):",
        ""
      ],
      "output": "",
      "code_length": 4171,
      "line_count": 69
    }
  ],
  "firebase_enabled": true,
  "last_updated": "2025-10-15T10:03:01.513001"
}